//////////------------------------------------------------------------------
// Java Code for JForex of Strategy 0.12
//
//   Generated by StrategyQuant X Build 130
//   at 11/09/2020 09:58
//
//   Backtested on EURUSD_M1 / H1, 2003.05.05 - 2020.03.19 
//  
//+------------------------------------------------------------------+

package jforex;

import java.util.*;
import java.io.*;
import java.awt.Color;
import java.awt.Toolkit;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.HashMap;
import java.util.Map;
import java.util.Calendar;
import java.util.Date;
import java.text.SimpleDateFormat;

import com.dukascopy.api.IIndicators.AppliedPrice;
import static com.dukascopy.api.IIndicators.AppliedPrice.*;
import com.dukascopy.api.IEngine.OrderCommand;
import static com.dukascopy.api.IEngine.OrderCommand.*;
import com.dukascopy.api.IOrder.State;
import static com.dukascopy.api.IOrder.State.*;
import static com.dukascopy.api.OfferSide.*;
import com.dukascopy.api.IIndicators.MaType;
import static com.dukascopy.api.IIndicators.MaType.*;
import com.dukascopy.api.Unit;
import static com.dukascopy.api.Unit.*;

import com.dukascopy.api.*;

public class Strategy implements IStrategy {
    private IEngine engine;
    private IConsole console;
    private IHistory history;
    private IContext context;
    private IIndicators indicators;
    private IUserInterface userInterface;

    private IOrder order;
    private List<IOrder> orders;
    private Instrument instrument;
    private Period period;
    private OrderCommand orderType;
    private IBar bar;
    private int counter = 1; 
    private String ticket;
    private Calendar calendar = Calendar.getInstance();
    private long time;
    private double amount;
    private double initialBalance = 0;
    
    private boolean openingOrdersAllowed = true;
        
    private static final int SLPTTYPE_RANGE = 0;
    private static final int SLPTTYPE_LEVEL = 1;
    
    private static final int MODE_SMA = 0; //Simple averaging
    private static final int MODE_EMA = 1; //Exponential averaging
    private static final int MODE_SMMA = 2; //Smoothed averaging
    private static final int MODE_LWMA = 3; //Linear-weighted averaging
    
    private static final int MODE_MAIN = 0;
    private static final int MODE_SIGNAL = 1;
    private static final int MODE_PLUSDI = 1;
    private static final int MODE_MINUSDI = 2;
    
    @Configurable("Instrument")
    public Instrument selectedInstrument = Instrument.EURUSD;
    @Configurable("Period")
    public Period selectedPeriod = Period.DAILY;
    @Configurable(value = "Custom Comment")
    public String CustomComment = "Strategy 0.12";

    //------------------------------------------------------------------+
    // -- SQ internal variables
    //------------------------------------------------------------------+
    private int sqMaxEntrySlippage = 5;          //Max tolerated entry slippage in pips. Zero means unlimited slippage
    private int sqMaxCloseSlippage = 0;          //Max tolerated close slippage in pips. Zero means unlimited slippage       
    private boolean autoCorrectMaxSlippage = true;  //If set to true, it will automatically adjust max slippage according to symbol digits (*10 for 3 and 5 digit symbols)  
        
    private boolean cond[] = new boolean[100];    
        
    private Map<String, Double> globalVariables = new HashMap<String, Double>();
    private Map<Integer, Period> periodsMap = new HashMap<Integer, Period>();
    private Map<String, Instrument> instrumentsMap = new HashMap<String, Instrument>();
        
    private int errors = 0;    
        

    // Strategy variables
        private int MagicNumber = 11111;
        private int BBBarOpensPeriod = 96;
        private int ATRChangesUpPeriod = 50;
        private double PriceEntryMult = 1.9;
        private int ProfitTarget = 90;
        private int StopLoss = 65;
        private double TrailingStopCoef = 4.2;
        private double TrailingActCef = 3.4;
        private int MTKeltnerChannelPrd = 43;
        private int ATRPeriod = 125;

    // Trading Options
    @Configurable(value = "--------- Trading Options ---------", readOnly = true)
    public String tradingOptions = "";
    
    @Configurable(value = "Exit At End Of Day")
    public boolean ExitAtEndOfDay = true;
    @Configurable(value = "End Of Day Exit Time")
    public String DayExitTime = "14:00";
    
    @Configurable(value = "Exit On Friday")
    public boolean ExitOnFriday = true;
    @Configurable(value = "Friday Exit Time")
    public String FridayExitTime = "14:00";
    @Configurable(value = "Limit Time Range")
    public boolean LimitSignalsTimeRange = false;
    @Configurable(value = "Time Range From")
    public String SignalTimeRangeFrom = "08:00";
    @Configurable(value = "Time Range To")
    public String  SignalTimeRangeTo = "16:00";
    @Configurable(value = "Exit At End Of Range")
    public boolean ExitAtEndOfRange = false;
    
    @Configurable(value = "Maximum Trades Per Day", stepSize = 1)
    public int MaxTradesPerDay = 0;
    @Configurable(value = "Minimum SL", stepSize = 1)
    public int MinimumSL = 30;  // Minimum SL in ticks/pips, 0 means unlimited
    @Configurable(value = "Maximum SL", stepSize = 1)
    public int MaximumSL = 100;  // Maximum SL in ticks/pips, 0 means unlimited
    @Configurable(value = "Minimum PT", stepSize = 1)
    public int MinimumPT = 0;  // Minimum PT in ticks/pips, 0 means unlimited
    @Configurable(value = "Maximum PT", stepSize = 1)
    public int MaximumPT = 0;  // Maximum PT in ticks/pips, 0 means unlimited    

    // Money Management - Fixed size
    @Configurable(value = "--------- Money Management ---------", readOnly = true)
    public String mmType = "Fixed size";
    @Configurable(value = "Order size", stepSize = 0.1)
    public double mmLots = 1.0;
    private double InitialCapital = 10000;  

    // Internal variables
        private boolean LongEntrySignal = false;
        private boolean ShortEntrySignal = false;
        private boolean LongExitSignal = false;
        private boolean ShortExitSignal = false;
    
      
private String slts = "----------- Use Tick size from SQ (for CFDs) -----------";
// For exotic pairs (usually non forex CFDs) the default method of computing 
// tick size in EA might not work correctly.
// By turning this on and specifying MainChartTickSizeSQ value you can let EA 
// use the correct tick size          
private boolean UseSQTickSize = false;                                                                             
private double MainChartTickSizeSQ = 1.0E-4;
 
private List<File> files = new ArrayList<File>();
private List<BufferedWriter> writers = new ArrayList<BufferedWriter>();
 
    @Override
    public void onStart(IContext context) throws JFException {
        this.engine = context.getEngine();
        this.console = context.getConsole();
        this.history = context.getHistory();
        this.context = context;
        this.indicators = context.getIndicators();
        this.userInterface = context.getUserInterface();
        
        print("--------------------------------------------------------");
        print("Starting the EA");
        print("--------------------------------------------------------");
            
        //subscribe an instrument:
        Set<Instrument> instruments = new HashSet<Instrument>();
        instruments.add(selectedInstrument);                     
        context.setSubscribedInstruments(instruments, true);
        
        initialBalance = context.getAccount().getBalance();
        
		try {
			print("Registering custom indicators located in ...\\JForex\\Strategies\\files folder");
			File f = context.getFilesDir();
			
			FilenameFilter filter = new FilenameFilter() {
				@Override
				public boolean accept(File f, String name) {
					return name.endsWith(".jfx");
				}
			};
			File[] files = f.listFiles(filter);
			for (int i = 0; i < files.length; i++) {
				File fCustomIndy = files[i];
				
				print(String.format("Registering custom indicator %s", fCustomIndy.getAbsolutePath()));
				this.indicators.registerCustomIndicator(fCustomIndy);
			}
		} catch(Exception e) {
			print("Error while loading Custom indicators. " + e.getMessage());
		}
		
        print("Initial balance: ", initialBalance);
		
		addExportFile("ADX_14_Main.csv");
		addExportFile("ADX_14_DI-.csv");
		addExportFile("ADX_14_DI+.csv");
		addExportFile("Aroon_14_up.csv");
		addExportFile("Aroon_14_down.csv");
		addExportFile("ATR_14.csv");
		addExportFile("AvgVolume_14.csv");
		addExportFile("Awesome_Oscillator.csv");
		addExportFile("BBRange_16_2.2_Low.csv");
		addExportFile("BBWidthRatio_20_2_Open.csv");
		addExportFile("BB_20_0_2.0_Upper.csv");
		addExportFile("BB_20_0_2.0_Lower.csv");
		addExportFile("BearsPower_Close_14.csv");
		addExportFile("BullsPower_Close_14.csv");
		addExportFile("CCI_Close_14.csv");
		addExportFile("CCI_Typical_14.csv");
		addExportFile("DeMarker_14.csv");
		addExportFile("EMA_Close_60.csv");
		addExportFile("HA_Close.csv");
		addExportFile("HA_Open.csv");
		addExportFile("Highest_10_Close.csv");
		addExportFile("HighestIndex_10_Close.csv");
		addExportFile("Ichimoku_9_26_52_KijunSen.csv");
		addExportFile("Ichimoku_9_26_52_SenkouSpanA.csv");
		addExportFile("Ichimoku_9_26_52_SenkouSpanB.csv");
		addExportFile("Ichimoku_9_26_52_TenkanSen.csv");
		addExportFile("Ichimoku_21_33_28_TenkanSen.csv");
		addExportFile("KeltnerChannel_16_0.2_Upper.csv");
		addExportFile("KeltnerChannel_16_0.2_Lower.csv");
		addExportFile("LinearRegression_14_Low.csv");
		addExportFile("LowestIndex_10_Close.csv");
		addExportFile("LWMA_14_Close.csv");
		addExportFile("MACD_Close_12_26_9_Main.csv");
		addExportFile("MACD_Close_12_26_9_Signal.csv");
		addExportFile("Momentum_Close_60.csv");
		addExportFile("MTATR_14.csv");
		addExportFile("MTKeltnerChannel_16_0.2_Upper.csv");
		addExportFile("MTKeltnerChannel_16_0.2_Lower.csv");
		addExportFile("OSMA_Close_12_26_9.csv");
		addExportFile("ParabolicSAR_0.02_0.2.csv");
		addExportFile("RSI_Close_14.csv");
		addExportFile("SMA_Close_60.csv");
		addExportFile("SMMA_14_Close.csv");
		addExportFile("StdDev_Close_20.csv");
		addExportFile("STOCH_20_10_45_EMA_HL_FastK.csv");
		addExportFile("STOCH_20_10_45_EMA_HL_SLOWD.csv");
		addExportFile("TEMA_Close_14.csv");
		addExportFile("WilliamsPR_14.csv");
		addExportFile("Fractals_3_Up.csv");
		addExportFile("Fractals_3_Down.csv");
		addExportFile("Fractals_5_Up.csv");
		addExportFile("GannHiLo_10.csv");
		addExportFile("Vortex_12_Plus.csv");
		addExportFile("Vortex_12_Minus.csv");
    }
	
	private void addExportFile(String name) throws JFException {
		try {
			File f = new File(context.getFilesDir(), name);						
			
			print("Creating indicator file", name);
			
			files.add(f);
			writers.add(new BufferedWriter(new FileWriter(f)));
		} catch (Exception e) {
			throw new JFException(String.format("Cannot open file %s.", name), e);
		}
	}

    @Override
    public void onAccount(IAccount account) throws JFException {
    }

    @Override
    public void onMessage(IMessage message) throws JFException {
        String reasons = "";
        for(IMessage.Reason reason : message.getReasons()) {
            reasons+=", "+reason.toString();
        }
    
        switch(message.getType()){
            case ORDER_SUBMIT_OK : 
                print("Order opened: " + message.getOrder(), reasons);
                break;
            case ORDER_SUBMIT_REJECTED : 
                print("Order open failed: " + message.getOrder(), reasons);
                break;
            case ORDER_FILL_OK : 
                print("Order filled: " + message.getOrder(), reasons);
                break;
            case ORDER_FILL_REJECTED : 
                print("Order cancelled: " + message.getOrder(), reasons);
                break;
            default:
                if(message.getOrder() == null) {
                    print(message.getContent(), reasons);
                } else {
                    print(message.getContent() + ", order: " + message.getOrder().getLabel(), reasons);
                }
                break;
        }
    }

    @Override
    public void onStop() throws JFException {
        print("Strategy is going to close.");
        
		for(BufferedWriter w : writers) {
			try {
				w.close();
			} catch (Exception e) {}
		}

        //close all existing orders
        print("Closing all existing orders");
        for (IOrder order : engine.getOrders()) {
                order.close();
        }
        
        if(errors > 0) {
            print(String.format("There were some errors (%d) while running the strategy. Please check the log for more details.", errors));
        }
        
        Toolkit.getDefaultToolkit().beep();
    }

    @Override
    public void onTick(Instrument instrument, ITick tick) throws JFException {
        //openingOrdersAllowed = sqHandleTradingOptions();    
    }

    @Override
    public void onBar(Instrument instrument, Period period, IBar askBar, IBar bidBar) throws JFException {
        try {
            if(instrument != this.selectedInstrument || period != this.selectedPeriod){
                return;
            }
            
            time = history.getStartTimeOfCurrentBar(instrument, period);
            
            calendar.setTimeInMillis(time);
            //if(calendar.get(Calendar.YEAR) < 2019) return;
            
            if(context.getDataService().isOfflineTime(time)) return;

			Number value;

			for(int i=0; i<files.size(); i++) {
				String name = files.get(i).getName();
				BufferedWriter writer = writers.get(i);

				value = null;

				switch(name) {
					case "ADX_14_Main.csv": 					value = sqADX("Current", 0, 14, 0, 1); break;
					case "ADX_14_DI-.csv": 						value = sqADX("Current", 0, 14, 2, 1); break;
					case "ADX_14_DI+.csv": 						value = sqADX("Current", 0, 14, 1, 1); break;
					case "Aroon_14_up.csv":	 					value = sqAroon("Current", 0, 14, 0, 1); break;
					case "Aroon_14_down.csv": 					value = sqAroon("Current", 0, 14, 1, 1); break;
					case "ATR_14.csv": 							value = sqATR("Current", 0, 14, 1); break;
					case "AvgVolume_14.csv": 					value = sqAvgVolume("Current", 0, 14, 1); break;
					case "Awesome_Oscillator.csv": 				value = sqAO("Current", 0, 1); break;
					case "BBRange_16_2.2_Low.csv": 				value = sqBBRange("Current", 0, 16, 2.2, LOW, 1); break;
					case "BBWidthRatio_20_2_Open.csv": 			value = sqBBWidthRatio("Current", 0, 20, 2, OPEN, 1); break;
					case "BB_20_0_2.0_Upper.csv": 				value = sqBands("Current", 0, 20, 2, 0, CLOSE, 0, 1); break;
					case "BB_20_0_2.0_Lower.csv": 				value = sqBands("Current", 0, 20, 2, 0, CLOSE, 1, 1); break;
					case "BearsPower_Close_14.csv": 			value = sqBearsPower("Current", 0, 14, CLOSE, 1); break;
					case "BullsPower_Close_14.csv": 			value = sqBullsPower("Current", 0, 14, CLOSE, 1); break;
					case "CCI_Close_14.csv": 					value = sqCCI("Current", 0, 14, CLOSE, 1); break;
					case "CCI_Typical_14.csv": 					value = sqCCI("Current", 0, 14, TYPICAL_PRICE, 1); break;
					case "DeMarker_14.csv": 					value = sqDeMarker("Current", 0, 14, 1); break;
					case "EMA_Close_60.csv": 					value = sqMA("Current", 0, 60, 0, MODE_EMA, CLOSE, 1); break;
					case "HA_Close.csv": 						value = sqHeikenAshi("Current", 0, 1, 1); break;
					case "HA_Open.csv": 						value = sqHeikenAshi("Current", 0, 0, 1); break;
					case "Highest_10_Close.csv": 				value = sqHighest("Current", 0, CLOSE, 10, 1); break;
					case "HighestIndex_10_Close.csv": 			value = sqHighestIndex("Current", 0, CLOSE, 10, 1); break;
					case "Ichimoku_9_26_52_KijunSen.csv": 		value = sqIchimoku("Current", 0, 9, 26, 52, 1, 1); break;
					case "Ichimoku_9_26_52_SenkouSpanA.csv": 	value = sqIchimoku("Current", 0, 9, 26, 52, 2, 1); break;
					case "Ichimoku_9_26_52_SenkouSpanB.csv": 	value = sqIchimoku("Current", 0, 9, 26, 52, 3, 1); break;
					case "Ichimoku_9_26_52_TenkanSen.csv": 		value = sqIchimoku("Current", 0, 9, 26, 52, 0, 1); break;
					case "Ichimoku_21_33_28_TenkanSen.csv": 	value = sqIchimoku("Current", 0, 21, 33, 28, 0, 1); break;
					case "KeltnerChannel_16_0.2_Upper.csv": 	value = sqKeltnerChannel("Current", 0, 16, 0.2, 1, 1); break;
					case "KeltnerChannel_16_0.2_Lower.csv": 	value = sqKeltnerChannel("Current", 0, 16, 0.2, 0, 1); break;
					case "LinearRegression_14_Low.csv": 		value = sqLinReg("Current", 0, 14, HIGH, 1); break;
					case "LowestIndex_10_Close.csv": 			value = sqLowestIndex("Current", 0, CLOSE, 10, 1); break;
					case "LWMA_14_Close.csv": 					value = sqMA("Current", 0, 14, 0, MODE_LWMA, CLOSE, 1); break;
					case "MACD_Close_12_26_9_Main.csv": 		value = sqMACD("Current", 0, 12, 26, 9, CLOSE, 0, 1); break;
					case "MACD_Close_12_26_9_Signal.csv": 		value = sqMACD("Current", 0, 12, 26, 9, CLOSE, 1, 1); break;
					case "Momentum_Close_60.csv": 				value = sqMomentum("Current", 0, 60, CLOSE, 1); break;
					case "MTATR_14.csv": 						value = roundValue(sqATR("Current", 0, 14, 0)); break;
					case "MTKeltnerChannel_16_0.2_Upper.csv": 	value = sqKeltnerChannel("Current", 0, 16, 0.2, 0, 1); break;
					case "MTKeltnerChannel_16_0.2_Lower.csv": 	value = sqKeltnerChannel("Current", 0, 16, 0.2, 1, 1); break;
					case "OSMA_Close_12_26_9.csv": 				value = sqOsMA("Current", 0, 12, 26, 9, CLOSE, 1); break;
					case "ParabolicSAR_0.02_0.2.csv": 			value = sqSAR("Current", 0, 0.02, 0.2, 1); break;
					case "RSI_Close_14.csv": 					value = sqRSI("Current", 0, 14, CLOSE, 1); break;
					case "SMA_Close_60.csv": 					value = sqMA("Current", 0, 60, 0, MODE_SMA, CLOSE, 1); break;
					case "SMMA_14_Close.csv":	 				value = sqMA("Current", 0, 14, 0, MODE_SMMA, CLOSE, 1); break;
					//case "StdDev_Close_20.csv": 				value = sqStdDev("Current", 0, 20, 0, MODE_SMA, CLOSE, 1); break;
					case "STOCH_20_10_45_EMA_HL_FastK.csv": 	value = sqStochastic("Current", 0, 20, 10, 45, 1, 0, 0, 1); break;
					case "STOCH_20_10_45_EMA_HL_SLOWD.csv": 	value = sqStochastic("Current", 0, 20, 10, 45, 1, 0, 1, 1); break;
					case "TEMA_Close_14.csv": 					value = sqTEMA("Current", 0, 14, CLOSE, 1); break;
					case "WilliamsPR_14.csv": 					value = sqWPR("Current", 0, 14, 1); break;
					//case "Fractals_3_Up.csv": 					value = sqFractal("Current", 0, 3, 0, 1); break;
					//case "Fractals_3_Down.csv": 				value = sqFractal("Current", 0, 3, 1, 1); break;
					//case "Fractals_5_Up.csv": 					value = sqFractal("Current", 0, 5, 0, 1); break;
					case "GannHiLo_10.csv": 					value = sqGannHiLo("Current", 0, 10, 0, 1); break;
					case "Vortex_12_Plus.csv": 					value = sqVortex("Current", 0, 12, 0, 1); break;
					case "Vortex_12_Minus.csv": 				value = sqVortex("Current", 0, 12, 1, 1); break;
				}
				
				if(value!=null)	writer.append(String.format("%s; %s; %s; %s; %s; %s; %s\n", SQTime.toFullDateMinuteString(bidBar.getTime()), bidBar.getOpen(), bidBar.getHigh(), bidBar.getLow(), bidBar.getClose(), bidBar.getVolume(), value));
			}
        } catch(Exception e) {
            print(String.format("ERROR: %s", e.getMessage()));            
            errors++;

            throw new JFException("Error", e);
        }
    }
    
private double sqVortex(String symbol, int timeframe, int period, int line, int shift) throws JFException {
	 return this.calculateIndicatorLineValue("vortex", symbol, timeframe, null, line, shift, period);
}

//------------------------------------------------------------------

private double sqGannHiLo(String symbol, int timeframe, int period, int line, int shift) throws JFException {
	return this.calculateIndicatorLineValue("gann_hilo", symbol, timeframe, null, line, shift, period);
}
	
//------------------------------------------------------------------

//------------------------------------------------------------------

private boolean sqHandleTradingOptions() throws JFException {
   boolean _openingOrdersAllowed = true;

   if(!objExitAtEndOfDay.onTick()) _openingOrdersAllowed = false;
   if(!objExitOnFriday.onTick()) _openingOrdersAllowed = false;
   if(!objLimitTimeRange.onTick()) _openingOrdersAllowed = false;
   if(!objMaxTradesPerDay.onTick()) _openingOrdersAllowed = false;
   if(!objMinMaxSLPT.onTick()) _openingOrdersAllowed = false;

   return _openingOrdersAllowed;
}   
	
	
//------------------------------------------------------------------

private boolean checkMagicNumber(int magicNo){
	if(magicNo == MagicNumber){
		 return true;
	}
	
	return false;
}
		
//----------------------------------------------------------------------------

private void sqResetGlobalVariablesForTicket(String ticket) throws JFException {
   sqSetGlobalVariable(ticket, "sqOrderExpiration", 0);
   sqSetGlobalVariable(ticket, "sqOrderOpenTime", getCurrentTime());

   sqSetGlobalVariable(ticket, "MoveSL2BE", 0);    
   sqSetGlobalVariable(ticket, "SL2BEAddPips", 0);
   sqSetGlobalVariable(ticket, "TrailingStop", 0);       
   sqSetGlobalVariable(ticket, "TrailingActivation", 0);
   sqSetGlobalVariable(ticket, "ExitAfterBars", 0);
  
}
		
//------------------------------------------------------------------	
	

private void print(Object o){
	context.getConsole().getOut().println(o);
}

//------------------------------------------------------------------

private void print(Object ...data ) {
	for(Object o : data) {
		context.getConsole().getOut().print(o+", ");
	}
	
	context.getConsole().getOut().println("");
}

//------------------------------------------------------------------

private void printBarStartTime(Instrument instrument, Period period) throws JFException {
	long startTime = history.getStartTimeOfCurrentBar(instrument, period);
	context.getConsole().getOut().println(SQTime.toFullDateMinuteString(startTime));
}

//------------------------------------------------------------------

private IOrder sqOpenOrder(OrderCommand orderType, String symbol, double size, double price, int magicNumber, String comment, long expirationInTime, boolean replaceExisting, boolean allowDuplicateTrades, Color arrowColor, boolean isExitLevel) throws JFException {
	if(size <= 0) return null;
	
	print("Opening order type " + orderType + " with price " + price);
	
	String correctedSymbol = correctSymbol(symbol);
	instrument = getInstrument(correctedSymbol);
	
	double ask = sqGetAsk(symbol);
	double bid = sqGetBid(symbol);

	int direction = sqGetDirectionFromOrderType(orderType);

	double marketPrice = direction == 1 ? ask : bid;

	price = price > 0 ? price : marketPrice;                
	price = sqFixMarketPrice(price, instrument);

	//openingOrdersAllowed = openingOrdersAllowed && sqHandleTradingOptions();
	if(!openingOrdersAllowed)  return null;
	
	print("Opening order type " + orderType + " with price " + price + ", size "+size+". Current market prices: " + ask + " / " + bid);

	// check if live order exists
	order = sqGetOrder(magicNumber, correctedSymbol, 0, comment, true, true, false);
	if(!isExitLevel && order!=null && !allowDuplicateTrades) {
	  print("Order with these parameters already exists and duplicate trades are not allowed. Canceling order...");
	  print("----------------------------------");
	  return null;
	}

	amount = size / 10;

	// check if pending order exists
	if(!isExitLevel){
		order = sqGetOrder(magicNumber, correctedSymbol, direction, comment, false, false, true);
		if(order!=null) {
		  if(replaceExisting) {
			 if(amount == order.getAmount()) {
				// modify existing pending order
				if(sqOrderModify(order, price, 0, 0, expirationInTime)) {
				   // reset global variables for this order
				   sqResetGlobalVariablesForTicket(order.getLabel());
				   return order;
				
				} else {
				   print("Modifying order failed, deleting it");
				   sqDeletePendingOrder(order, "Open order - failed to modify existing pending order");
				   return null;
				}
			 } else {
				// delete existing pending order
				sqDeletePendingOrder(order, "Open order - deleting existing pending order");
			 }

		  } else {
			 print("Pending Order with these parameters already exists, and replace is not allowed. Canceling order...");
			 return null;
		  }
		}
	}

	if(!checkOrderPriceValid(orderType, correctedSymbol, price, marketPrice)){
	  return null;
	}

	String commentToUse = "";
	if(!comment.isEmpty()){
	  commentToUse = comment;
	} else {
	  commentToUse = CustomComment;
	  commentToUse = commentToUse.replaceAll("Optimization", "Opt.");     //shorten the name of optimized strategies
	}
	
	if(commentToUse.length() > 30) {
		commentToUse = commentToUse.substring(0, 30);           //limit the length to 30 characters
	}
	
	String label = getLabel(instrument, magicNumber);
		
	order = engine.submitOrder(label, instrument, orderType, amount, price, correctSlippage(sqMaxEntrySlippage, correctedSymbol), 0, 0, expirationInTime, commentToUse);
	if(order != null) {
	  print("Opened order with ticket " + label + " ----------------");	
	  // reset global variables for this order
	  sqResetGlobalVariablesForTicket(order.getLabel());
	}

	return order;
}

//----------------------------------------------------------------------------

private boolean sqCheckConnected() {
	return true;
}

//----------------------------------------------------------------------------

private boolean checkOrderPriceValid(OrderCommand orderType, String symbol, double price, double marketPrice){
   if(orderType == BUY || orderType == SELL){
      if(marketPrice == price){
         return true;
      }
      else {
         print("Based on its logic, the strategy tried to place order a market order at incorrect price. Market price: " + marketPrice + ", order price: " + price + " (this is NOT an error)");
         return false;
      }
   }
   
   return checkStopPriceValid(orderType, symbol, price, marketPrice, "stop/limit order");
}

//----------------------------------------------------------------------------

private boolean checkStopPriceValid(OrderCommand orderType, String symbol, double price, double marketPrice, String name){
	return true;
}  

//----------------------------------------------------------------------------

private boolean sqDeletePendingOrder(IOrder order, String reason) throws JFException {
	print("Deleting pending order, ticket: " + order.getLabel() + ", reason: " + reason);

	orderType = order.getOrderCommand();

	if(!orderType.isConditional()) {
		print("Trying to delete non-pending order");
		return false;
	}
	if(!sqCheckConnected()) {
		return false;
	}
	 
	if(order.getState() == FILLED || order.getState() == OPENED){
		order.close();
		print("Order deleted successfuly");
		return true;
	} else {
		print("Unable to close order in state: " + order.getState());
		return false;
	}
}

//+------------------------------------------------------------------+

private boolean sqOrderModifySL(IOrder order, double stopLoss, int type) throws JFException {
   if(type == SLPTTYPE_RANGE) {
      // convert range to price level
      if(sqGetDirectionFromOrderType(order.getOrderCommand()) == 1) {
         // it is long order
         stopLoss = order.getOpenPrice() - stopLoss;
      } else {
         stopLoss = order.getOpenPrice() + stopLoss;
      }
   }

   return(sqOrderModify(order, order.getOpenPrice(), sqFixMarketPrice(stopLoss, order.getInstrument()), order.getTakeProfitPrice()));
}

//+------------------------------------------------------------------+

private boolean sqOrderModifyPT(IOrder order, double profitTarget, int type) throws JFException {
   if(type == SLPTTYPE_RANGE) {
      // convert range to price level
      if(sqGetDirectionFromOrderType(order.getOrderCommand()) == 1) {
         // it is long order
         profitTarget = order.getOpenPrice() + profitTarget;
      } else {
         profitTarget = order.getOpenPrice() - profitTarget;
      }
   }

   return(sqOrderModify(order, order.getOpenPrice(), order.getStopLossPrice(), sqFixMarketPrice(profitTarget, order.getInstrument())));
}

//+------------------------------------------------------------------+

//----------------------------------------------------------------------------

private boolean sqOrderModify(IOrder order, double price, double stopLoss, double profitTarget) throws JFException {
	return  sqOrderModify(order, price, stopLoss, profitTarget, -1);
}

//----------------------------------------------------------------------------

private boolean sqOrderModify(IOrder order, double price, double stopLoss, double profitTarget, long expirationInTime) throws JFException {
	print("Modifying order with ticket " + order.getLabel() + ", openPrice: " + price + ", sl: " + stopLoss + ", pt: " + profitTarget + ", state: " + order.getState());

	if (order.getState() == IOrder.State.CREATED) {
		order.waitForUpdate();
	}
	
	if ((order.getState() == IOrder.State.OPENED && order.getOrderCommand().isConditional()) || (order.getState() == IOrder.State.FILLED && order.getOrderCommand().isConditional() && order.getAmount() < order.getRequestedAmount())) {
		if(order.getOpenPrice() != price) order.setOpenPrice(price);
	}
	
	if(order.getState() == IOrder.State.FILLED || (order.getState() == IOrder.State.OPENED && order.getOrderCommand().isConditional())) {
		if(order.getStopLossPrice() != stopLoss) 		order.setStopLossPrice(stopLoss);
		if(order.getTakeProfitPrice() != profitTarget) 	order.setTakeProfitPrice(profitTarget);
	}
	
	if (order.getState() == IOrder.State.OPENED && order.getOrderCommand().isConditional()) {
		if(expirationInTime > 0) order.setGoodTillTime(expirationInTime);
	}
	
	print("Modified order with ticket " + order.getLabel() + ", openPrice: " + price + ", sl: " + stopLoss + ", pt: " + profitTarget);
	
	return true;
}

//----------------------------------------------------------------------------

private int correctSlippage(int slippage, String symbol){
    if(slippage <= 0) return 100000;
    
    return slippage;
}

//------------------------------------------------------------------

private String correctSymbol(String symbol){
  if(symbol.equals("NULL") || symbol.equals("Current") || symbol.equals("Same as main chart")) {
      return symbol;
  }
    else return symbol;
}

//------------------------------------------------------------------

private double sqGetAsk(String symbol) throws JFException {
	if(symbol.equals("NULL") || symbol.equals("Current")) {
		instrument = selectedInstrument;
	} else {
		instrument = getInstrument(correctSymbol(symbol));
	}	
   
	return sqGetAsk(instrument);
}

//------------------------------------------------------------------

private double sqGetAsk(Instrument instrument) throws JFException {
	return history.getLastTick(instrument).getAsk();
}

//------------------------------------------------------------------

private double sqGetBid(String symbol) throws JFException {
	if(symbol.equals("NULL") || symbol.equals("Current")) {
		instrument = selectedInstrument;
	} else {
		instrument = getInstrument(correctSymbol(symbol));
	}	
   
	return sqGetBid(instrument);
}

//------------------------------------------------------------------

private double sqGetBid(Instrument instrument) throws JFException {
	return history.getLastTick(instrument).getBid();
}


//------------------------------------------------------------------

private void sqClosePosition(double size, int magicNumber, String symbol, int direction, String comment, String reason) throws JFException {
   print("Closing order with Magic Number: " + magicNumber + ", symbol: " + symbol + ", direction: " + direction + ", comment: " + comment + ", reason: " + reason);

   order = sqGetOrder(magicNumber, symbol, direction, comment, false, false, false);

   if(order == null) {
      print("Order cannot be found");
   } else {
	  orderType = order.getOrderCommand();
	   
      if(!orderType.isConditional()) {
         sqClosePositionAtMarket(order, size, reason);
      } else {
         sqDeletePendingOrder(order, reason);
      }
   }

   print("Closing order finished ----------------");
}

//------------------------------------------------------------------

private boolean sqClosePositionAtMarket(IOrder order, double size, String reason) throws JFException {
	print("Closing order with ticket: " + order.getLabel() + ", reason: " + reason);

	orderType = order.getOrderCommand();

	if(orderType.isConditional()) {
      print("Trying to close non-live order");
      return false;
	}
   
	if(!sqCheckConnected()) {
      return false;
	}

	if(size > 0) {
		order.close(size / 10);
	} else {
		order.close(); //with size 0 it throws an exception
	}
	
	print("Order closed successfuly");
	
	return true;
}

//------------------------------------------------------------------

private void sqClosePendingOrder(int magicNumber, String symbol, int direction, String comment) throws JFException {
   print("Closing pending order with Magic Number: ", magicNumber, ", symbol: ", symbol, ", direction: ", direction, ", comment: ", comment);

   order = sqGetOrder(magicNumber, symbol, direction, comment, false, false, true);
   if(order==null) {
      print("Order cannot be found");
   } else {
      sqDeletePendingOrder(order, "Close pending order");
   }

   print("Closing pending order finished ----------------");
}

//------------------------------------------------------------------

private void sqCloseAllPendingOrders(int magicNumber, String symbol, int direction, String comment) throws JFException {
   print("Closing pending orders with Magic Number: ", magicNumber, ", symbol: ", symbol, ", direction: ", direction, ", comment: ", comment);

   while(true) {
	  order = sqGetOrder(magicNumber, symbol, direction, comment, false, false, true);
	  if(order==null) break;
	  
      sqDeletePendingOrder(order, "Close all pending orders");
   }

   print("Closing pending orders finished ----------------");
}

//------------------------------------------------------------------

private OrderCommand getOrderType(int orderType) {
	   switch(orderType) {
			 case 0: return BUY;
			 case 1: return SELL;
			 case 2: return BUYLIMIT;
			 case 3: return SELLLIMIT;
			 case 4: return BUYSTOP;
			 case 5: return SELLSTOP;
	   }
	   
	   return null;
}

//------------------------------------------------------------------

private IOrder  sqGetPendingOrderByType(int magicNumber, String symbol, int orderType, String comment) throws JFException {
   orders = engine.getOrders();	

   OrderCommand orderCommand = getOrderType(orderType);

   for (int cc = 0; cc < orders.size(); cc++) {
		 order = orders.get(cc);
		 
		 if(!order.getOrderCommand().isConditional()) {
			continue;
		 }
         
         if(orderType != 0) {
            if(orderCommand != order.getOrderCommand()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         // otherwise we found the order
         return order;
   }

   return null;
}

//------------------------------------------------------------------

private IOrder sqGetPendingOrderByDir(int magicNumber, String symbol, int direction, String comment) throws JFException {
   orders = engine.getOrders();	

   for (int cc = 0; cc < orders.size(); cc++) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();
		 
		 if(!orderType.isConditional()) {
			continue;
		 }
	   
         if(direction != 0) {
            int orderDirection = sqGetDirectionFromOrderType(orderType);
            if(orderDirection != direction) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

		 // otherwise we found the order
		 return order;
   }

   return null;
}

//------------------------------------------------------------------
//bool sqSelectOrder(int magicNumber, String symbol, int direction, String comment, bool goFromNewest=true, bool skipPending=true, bool skipFilled=false) {
private IOrder sqGetOrder(int magicNumber, String symbol, int direction, String comment, boolean goFromNewest, boolean skipPending, boolean skipFilled) throws JFException {
	instrument = getInstrument(symbol);
	    
	orders = engine.getOrders();	
		
    if(goFromNewest){
       for (int cc = orders.size() - 1; cc >= 0; cc--) {
		   order = orders.get(cc);
		   
           if(orderFits(order, magicNumber, symbol, direction, comment, skipPending, skipFilled)){
              return order;
           }
       }
    }
    else {
       for (int cc = 0; cc < orders.size(); cc++) {
		   order = orders.get(cc);
		   
           if(orderFits(order, magicNumber, symbol, direction, comment, skipPending, skipFilled)){
              return order;
           }
       }
    }
	
    return null;
}

//------------------------------------------------------------------

private IOrder sqGetOrder(int magicNumber, String symbol, int direction, String comment, boolean goFromNewest, boolean skipPending) throws JFException {
	return sqGetOrder(magicNumber, symbol, direction, comment, goFromNewest, skipPending, false);
}

//------------------------------------------------------------------

private IOrder sqGetOrder(int magicNumber, String symbol, int direction, String comment, boolean goFromNewest) throws JFException {
	return sqGetOrder(magicNumber, symbol, direction, comment, goFromNewest, true, false);
}

//------------------------------------------------------------------

private IOrder sqGetOrder(int magicNumber, String symbol, int direction, String comment) throws JFException {
	return sqGetOrder(magicNumber, symbol, direction, comment, true, true, false);
}

//------------------------------------------------------------------

private boolean orderFits(IOrder order, int magicNumber, String symbol, int direction, String comment, boolean skipPending, boolean skipFilled){
	orderType = order.getOrderCommand();

	// skip pending orders
	if(skipPending && (orderType.isConditional())) {
		return false;
	}
	
	// skip filled orders
	if(skipFilled && (!orderType.isConditional())) {
		return false;
	}

	if(direction != 0) {
		if(direction > 0 && (!orderType.isLong())) return false;
		if(direction < 0 && (!orderType.isShort())) return false;
	}

	if(magicNumber != 0) {
		if(!checkMagicNumber(magicNumber) || !checkOrderMagicNumber(order, magicNumber)) return false;
	}

	if(!symbol.equals("Any")) {
		if(order.getInstrument() != getInstrument(symbol)) return false;
	}

	if(!comment.isEmpty()) {
		if(order.getComment().indexOf(comment) < 0) return false;
	}

	// otherwise we found the order
	return true;
}

//------------------------------------------------------------------

private boolean checkOrderMagicNumber(IOrder order, int magicNumber) {
	return order.getLabel().endsWith("_"+magicNumber);
}

//------------------------------------------------------------------

private int getOrderMagicNumber(IOrder order) {
	String label = order.getLabel();
	return Integer.valueOf(label.substring(label.lastIndexOf("_") + 1));
}

//------------------------------------------------------------------

private void sqManageOrders() throws JFException {
	orders = engine.getOrders();	
	
	for (int cc = orders.size() - 1; cc >= 0; cc--) {
		order = orders.get(cc);
		orderType = order.getOrderCommand();
		
		String label = order.getLabel();

		if(!orderType.isConditional()) {
			// handle Exit Methods only for live orders
			sqManageSL2BE(order);
			sqManageTrailingStop(order);            
			sqManageExitAfterXBars(order);               
		}
		
		sqManageOrderExpiration(order);
	}
}

//------------------------------------------------------------------

private Instrument getInstrument(String symbol) {
  if(symbol==null || symbol.equals("NULL") || symbol.equals("Current") || symbol.equals("Same as main chart")) {
      return selectedInstrument;
  }
    /*
  if(!instrumentsMap.containsKey(symbol)) {
	  instrument = Instrument.fromString(symbol);
	  if(instrument==null) throw new Exception("Invalid instrument: ", symbol);
	  
	  instrumentsMap.put(symbol, instrument));
  }
    
  return instrumentsMap.get(symbol);
  */
  
  return selectedInstrument;
}

//------------------------------------------------------------------

private Period getPeriod(int timeframe){
  if(timeframe == 0) {
      return selectedPeriod;
  }
  
  if(!periodsMap.containsKey(timeframe)) {
	 Period _period; 

	 switch(timeframe) {
		case 0:  		_period = Period.TICK; break;
		case 1:  		_period = Period.ONE_MIN; break; 
		case 5:  		_period = Period.FIVE_MINS ; break; 
		case 15:  		_period = Period.FIFTEEN_MINS; break; 
		case 30:  		_period = Period.THIRTY_MINS; break; 
		case 60:  		_period = Period.ONE_HOUR; break; 
		case 240:  		_period = Period.FOUR_HOURS; break; 
		case 1440:  	_period = Period.DAILY; break; 
		case 10080:  	_period = Period.WEEKLY; break;
		case 43200:  	_period = Period.MONTHLY; break;
		default: 		_period = Period.createCustomPeriod(Minute, timeframe); break;
	  }	  
	  
	  periodsMap.put(timeframe, _period);
  }
    
  return periodsMap.get(timeframe);
}

//------------------------------------------------------------------

private Period getSymbolPeriod(String symbol){
  //todo  
  return selectedPeriod; 
}

//------------------------------------------------------------------

private int sqGetDirectionFromOrderType(OrderCommand orderType) {
   if(orderType.isLong()) {
      return 1;
   } else {
      return -1;
   }
}

//------------------------------------------------------------------

private String getLabel(Instrument instr, int magicNumber) {
	String label = instr.name();
	label = label + "_" + (counter++) + "_" + magicNumber;
	label = label.toUpperCase();
	return label;
}

//------------------------------------------------------------------------

private double round(double amount, int decimalPlaces) {
    return (new BigDecimal(amount)).setScale(decimalPlaces, BigDecimal.ROUND_HALF_UP).doubleValue();
}

//------------------------------------------------------------------

private double roundDown(double amount, int decimalPlaces) {
	return (new BigDecimal(amount)).setScale(decimalPlaces, BigDecimal.ROUND_HALF_DOWN).doubleValue();
}

//------------------------------------------------------------------------

private double roundToPippette(double amount, Instrument instrument) {
    return round(amount, instrument.getPipScale() + 1);
}

//------------------------------------------------------------------

private double sqConvertToRealPips(Instrument instrument, double value) {
   return value * instrument.getPipValue();
}

//------------------------------------------------------------------

private double sqConvertToRealPips(String symbol, double value) {
   instrument = getInstrument(symbol);
   
   return sqConvertToRealPips(instrument, value);
}

//------------------------------------------------------------------+

private int sqConvertToPips(Instrument instrument, double value) {
   return (int)(value / instrument.getPipValue());
}  

//------------------------------------------------------------------+

private int sqConvertToPips(String symbol, double value) {
   instrument = getInstrument(symbol);

   return sqConvertToPips(instrument, value);
}  

//------------------------------------------------------------------

private double sqFixMarketPrice(double price, Instrument instr) {
	BigDecimal bd = new BigDecimal(price);
	bd = bd.setScale(instr.getPipScale() + 1, RoundingMode.HALF_UP);
	return bd.doubleValue();
}

//+------------------------------------------------------------------+

double fixLotSize(String symbol, double size){
   return size;
}

//------------------------------------------------------------------

private boolean sqIsUptrend(String symbol, int timeframe, int method) throws JFException {
   if(method == 0) {
      return (sqClose(symbol, timeframe, 1) > sqMA(symbol, timeframe, 200, 0, MODE_SMA, CLOSE, 1));      
   }

   return false;	
}

//------------------------------------------------------------------

private boolean sqIsDowntrend(String symbol, int timeframe, int method) throws JFException {
   if(method == 0) {
      return (sqClose(symbol, timeframe, 1) < sqMA(symbol, timeframe, 200, 0, MODE_SMA, CLOSE, 1));      
   }

   return false;	
}

//------------------------------------------------------------------

private double roundPips(double pips) {
	BigDecimal bd = new BigDecimal(pips);
	bd = bd.setScale(1, RoundingMode.HALF_UP);
	return bd.doubleValue();
}

//------------------------------------------------------------------

private void sqSetSLandPT(IOrder order, double sl, double pt) throws JFException {
   if(sl == 0 && pt == 0) return;
   
   if(sl == order.getOpenPrice()) {
      print("SL is the same as order price, cannot set it, so we'll delete the order!");
	  order.close();

      return;
   }

   if(pt == order.getOpenPrice()) {
      pt = 0;
   }
   
   if(sl > 0 || pt > 0) {
      boolean result = sqOrderModify(order, order.getOpenPrice(), sqFixMarketPrice(sl, order.getInstrument()), sqFixMarketPrice(pt, order.getInstrument()));
      if(!result) {
         print("Cannot set SL / PT for this order, deleting it!");
         order.close();
      }
   }
}

//------------------------------------------------------------------

private double sqGetSLLevel(String symbol, OrderCommand orderType, double price, int valueInPips, double value) throws JFException {
   return sqGetSLPTLevel(-1.0, symbol, orderType, price, valueInPips, value);
}

//------------------------------------------------------------------

private double sqGetPTLevel(String symbol, OrderCommand orderType, double price, int valueInPips, double value) throws JFException {
   return sqGetSLPTLevel(1.0, symbol, orderType, price, valueInPips, value);
}

//------------------------------------------------------------------

/**
* valueType: 1 - pips, 2 - real pips (ATR range), 3 - price level
*/
private double sqGetSLPTLevel(double SLorPT, String symbol, OrderCommand orderType, double price, int valueType, double value) throws JFException {
   String correctedSymbol = correctSymbol(symbol);
   instrument = getInstrument(correctedSymbol);

   double pointCoef = instrument.getPipValue();

   if(valueType == 1) {
      // convert from pips to real points
      value = sqConvertToRealPips(instrument, value);
   }
   
   if(price == 0) {
      // price can be zero for market order
      if(orderType.isLong()) {
         price = sqGetAsk(correctedSymbol);
      } else {
         price = sqGetBid(correctedSymbol);
      }
   }
   
   double slptValue = value;
   
   if(valueType != 3) {
      if(orderType.isLong()) {
         slptValue = price + (SLorPT * value);
      } else {
         slptValue = price - (SLorPT * value);
      }
   }

   // check that SL / PT is within predefined boundaries
   double minSLPTValue, maxSLPTValue;
   
   if(SLorPT < 0) {
      // it is SL
      
      if(MinimumSL <= 0) {
         minSLPTValue = slptValue;
      } else {
         if(orderType.isLong()) {
            minSLPTValue = price + (SLorPT * MinimumSL * pointCoef);
            slptValue = Math.min(slptValue, minSLPTValue);
            
         } else {
         
            minSLPTValue = price - (SLorPT * MinimumSL * pointCoef);
            slptValue = Math.max(slptValue, minSLPTValue);
         }
   
      }
      
      if(MaximumSL <= 0) {
         maxSLPTValue = slptValue;
      } else {
         if(orderType.isLong()) {
            maxSLPTValue = price + (SLorPT * MaximumSL * pointCoef);
            slptValue = Math.max(slptValue, maxSLPTValue);

         } else {
            maxSLPTValue = price - (SLorPT * MaximumSL * pointCoef);
            slptValue = Math.min(slptValue, maxSLPTValue);
         }

      }
      
   } else {
      // it is PT

      if(MinimumPT <= 0) {
         minSLPTValue = slptValue;
      } else {
         if(orderType.isLong()) {
            minSLPTValue = price + (SLorPT * MinimumPT * pointCoef);
            slptValue = Math.max(slptValue, minSLPTValue);
            
         } else {
            minSLPTValue = price - (SLorPT * MinimumPT * pointCoef);
            slptValue = Math.min(slptValue, minSLPTValue);
         }

      }
      
      if(MaximumPT <= 0) {
         maxSLPTValue = slptValue;
      } else {

         if(orderType.isLong()) {
            maxSLPTValue = price + (SLorPT * MaximumPT * pointCoef);
            slptValue = Math.min(slptValue, maxSLPTValue);

         } else {
         
            maxSLPTValue = price - (SLorPT * MaximumPT * pointCoef);
            slptValue = Math.max(slptValue, maxSLPTValue);
         }
      }
   }
               
   return slptValue;
}  

//------------------------------------------------------------------

private void sqSetGlobalVariable(String ticket, String name, double value) {
   globalVariables.put(ticket+"_"+name, value);
}

//------------------------------------------------------------------

private double sqGetGlobalVariable(String ticket, String name) {
   Double value = globalVariables.get(ticket+"_"+name);
   if(value==null) value = 0d;
   
   return value;
}

//------------------------------------------------------------------

private int sqGetGlobalIntVariable(String ticket, String name) {
   Double value = globalVariables.get(ticket+"_"+name);
   if(value==null) value = 0d;
   
   return value.intValue();
}

//------------------------------------------------------------------

private long sqGetGlobalLongVariable(String ticket, String name) {
   Double value = globalVariables.get(ticket+"_"+name);
   if(value==null) value = 0d;
   
   return value.longValue();
}


//------------------------------------------------------------------

private boolean sqDoublesAreEqual(double value1, double value2){
	return Math.abs(value1 - value2) < 0.00000001;
}

//------------------------------------------------------------------+

private int sqStringHash(String str){
   int h = 0, k;
   for (int i=0; i<str.length(); i++){
      k = Character.getNumericValue(str.charAt(i));
      h = (h << 5) + h + k;
   }
   return h;
}

//------------------------------------------------------------------

private int sqGetOrderExpiration(String ticket) {
   return sqGetGlobalIntVariable(ticket, "sqOrderExpiration");
}

//------------------------------------------------------------------

private void sqSetOrderExpiration(String ticket, int bars) {
   sqSetGlobalVariable(ticket, "sqOrderExpiration", bars);
}

//------------------------------------------------------------------

private void sqCloseAllPositions(String symbol, int magicNumber, int direction, String comment) throws JFException {
   int count = 100; // maximum number of positions to close
   String lastTicket = "";

   while(count > 0) {
      count--;
	  
	  order = sqGetOrder(magicNumber, symbol, direction, comment, false, false);	  
      if(order==null) {
         // no position found
         break;
      }

      if(lastTicket.equals(order.getLabel())) {
         // trying to close the same position one more time, there must be some error
         break;
      }
      lastTicket = order.getLabel();

	  orderType = order.getOrderCommand();
      if(!orderType.isConditional()) {
         sqClosePositionAtMarket(order, 0, "Close all positions");
      } else {
         sqDeletePendingOrder(order, "Close all positions");
      }
   }
}

//------------------------------------------------------------------

private void sqCloseBestPosition(String symbol, int magicNumber, int direction, String comment) throws JFException {
   IOrder bestOrder = null;
   
   orders = engine.getOrders();	

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
	 order = orders.get(cc);
	 orderType = order.getOrderCommand();

	 // skip pending orders
	 if(orderType.isConditional()) {
		continue;
	 }

	 if(magicNumber != 0) {
		if(!checkOrderMagicNumber(order, magicNumber)) continue;
	 }  
	 else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;
	 
	 if(bestOrder==null || order.getProfitLossInAccountCurrency() > bestOrder.getProfitLossInAccountCurrency()) {
		// found order with better profit
		bestOrder = order;
		print("Better position found, ticket: ", order.getLabel(),", PL: ", order.getProfitLossInAccountCurrency());
	 }
   }

   if(bestOrder!=null) {
      sqClosePositionAtMarket(bestOrder, 0, "Close best position");
   }
}

//------------------------------------------------------------------

private void sqCloseWorstPosition(String symbol, int magicNumber, int direction, String comment) throws JFException {
   IOrder worstOrder = null;

   orders = engine.getOrders();	

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
	 order = orders.get(cc);
	 orderType = order.getOrderCommand();

	 // skip pending orders
	 if(orderType.isConditional()) {
		continue;
	 }

	 if(magicNumber != 0) {
		if(!checkOrderMagicNumber(order, magicNumber)) continue;
	 }  
	 else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;
         
	 if(worstOrder==null || order.getProfitLossInAccountCurrency() < worstOrder.getProfitLossInAccountCurrency()) {
		// found order with worse profit
		worstOrder = order;
		print("Worse position found, ticket: ", order.getLabel(),", PL: ", order.getProfitLossInAccountCurrency());
	 }
   }

   if(worstOrder!=null) {
      sqClosePositionAtMarket(worstOrder, 0, "Close worst position");
   }
}

//------------------------------------------------------------------

private int sqGetMarketPosition(String symbol, int magicNumber, String comment) throws JFException {
   order = sqGetOrder(magicNumber, symbol, 0, comment, false);
   if(order!=null) {
      if(order.getOrderCommand().isLong()) {
         return 1;
      } else {
         return -1;
      }
   }
   
   return 0;
}                     

//------------------------------------------------------------------

boolean sqMarketPositionIsShort(int magicNo, String symbol, String comment) throws JFException {
   return sqGetOrder(magicNo, symbol, -1, comment, false)!=null;
}    

//------------------------------------------------------------------

private boolean sqMarketPositionIsNotShort(int magicNo, String symbol, String comment) throws JFException {
	if(sqGetOrder(magicNo, symbol, -1, comment, false)!=null) {
      return false; 	
	}
	 
	 return true;
}     

//------------------------------------------------------------------

private boolean sqMarketPositionIsLong(int magicNo, String symbol, String comment) throws JFException {
   return sqGetOrder(magicNo, symbol, 1, comment, false)!=null;
}     

//------------------------------------------------------------------

private boolean sqMarketPositionIsNotLong(int magicNo, String symbol, String comment) throws JFException {
   if(sqGetOrder(magicNo, symbol, 1, comment, false)!=null) {
      return false; 	
	 }
	 
	 return true;
}     

//------------------------------------------------------------------

private boolean sqMarketPositionIsFlat(int magicNo, String symbol, String comment) throws JFException {
   return sqGetMarketPosition(symbol, magicNo, comment) == 0;
}

//------------------------------------------------------------------

private double sqGetOrderOpenPrice(String symbol, int magicNumber, int direction, String comment) throws JFException {
   order = sqGetOrder(magicNumber, symbol, 0, comment, false);
   if(order!=null) {
      return order.getOpenPrice();
   }
   return -1;
}

//------------------------------------------------------------------

private double sqGetOrderStopLoss(String symbol, int magicNumber, int direction, String comment) throws JFException {
   order = sqGetOrder(magicNumber, symbol, 0, comment, false);
   if(order!=null) {
      return order.getStopLossPrice();
   }
   return -1;
}

//------------------------------------------------------------------

private double sqGetOrderProfitTarget(String symbol, int magicNumber, int direction, String comment) throws JFException {
   order = sqGetOrder(magicNumber, symbol, 0, comment, false);
   if(order!=null) {
      return order.getTakeProfitPrice();
   }
   return -1;
}

//+------------------------------------------------------------------+

double sqGetMarketPositionSize(String symbol, int magicNumber, int direction, String comment) {
   double lots = 0;

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
	 order = orders.get(cc);
	 orderType = order.getOrderCommand();

	 // skip pending orders
	 if(orderType.isConditional()) {
		continue;
	 }
	 
	 if(direction != 0) {
		if(direction > 0 && !orderType.isLong()) continue;
		if(direction < 0 && !orderType.isShort()) continue;
	 }

	 if(magicNumber != 0) {
		if(!checkOrderMagicNumber(order, magicNumber)) continue;
	 }  
	 else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

	 if(!symbol.equals("Any")) {
		if(order.getInstrument() != getInstrument(symbol)) continue;
	 }

	 if(!comment.isEmpty()) {
		if(order.getComment().indexOf(comment) < 0) continue;
	 }

	 lots += order.getAmount() * 10;
   }

   return lots;
}

//------------------------------------------------------------------

private double sqGetOpenPL(String symbol, int magicNumber, int direction, String comment) throws JFException {
   double pl = 0;

   orders = engine.getOrders();	

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();
		 
         // skip pending orders
         if(orderType.isConditional()) {
            continue;
         }

         if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         pl += order.getProfitLossInAccountCurrency();
   }

   return pl;
}

//------------------------------------------------------------------

private double sqGetOpenPLInPips(String symbol, int magicNumber, int direction, String comment) throws JFException {
   double pl = 0;

   orders = engine.getOrders();	

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();

         // skip pending orders
         if(orderType.isConditional()) {
            continue;
         }

         if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         if(orderType.isLong()) {
            pl += sqGetBid(order.getInstrument()) - order.getOpenPrice();
         } else {
            pl += order.getOpenPrice() - sqGetAsk(order.getInstrument());
         }
   }

   return sqConvertToPips(order.getInstrument(), pl);
}

//------------------------------------------------------------------

private int sqGetClosedPLInPips(String symbol, int magicNumber, int direction, String comment, int shift) throws JFException {
   int index = 0;

   orders = sqGetHistoryOrders(symbol);

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();

         // skip pending orders
         if(orderType.isConditional()) {
            continue;
         }

         if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         if(index == shift) {
            if(orderType.isLong()) {
               return sqConvertToPips(order.getInstrument(), order.getClosePrice() - order.getOpenPrice());
            } else {
               return sqConvertToPips(order.getInstrument(), order.getOpenPrice() - order.getClosePrice());
            }
         }

         index++;
   }

   return 0;
}

//------------------------------------------------------------------
private List<IOrder> sqGetHistoryOrders(String symbol) throws JFException {
	List<IOrder> historyOrders = new ArrayList<IOrder>();
	
	long from = 0;
	long to = System.currentTimeMillis();

	if(symbol.equals("Any")) {
		for (Instrument instrument : context.getSubscribedInstruments()){
			historyOrders.addAll(history.getOrdersHistory(instrument, from, to));
		}
	} else {
		instrument = getInstrument(symbol);
		historyOrders.addAll(history.getOrdersHistory(instrument, from, to));
	}
	
	return historyOrders;
}

//------------------------------------------------------------------

private double sqGetClosedPLInMoney(String symbol, int magicNumber, int direction, String comment, int shift) throws JFException {
   int index = 0;

   orders = sqGetHistoryOrders(symbol);

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();

         // skip pending orders
         if(orderType.isConditional()) {
            continue;
         }

         if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         if(index == shift) {
            return order.getProfitLossInAccountCurrency();
         }

         index++;
   }

   return 0;
}

//------------------------------------------------------------------

private int sqGetMarketPositionCount(String symbol, int magicNumber, int direction, String comment) throws JFException {
   int count = 0;

   orders = engine.getOrders();	

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();

         // skip pending orders
         if(orderType.isConditional()) {
            continue;
         }

         if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
         }

         if(magicNumber != 0) {
            if(!checkOrderMagicNumber(order, magicNumber)) continue;
         }  
         else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

         if(!symbol.equals("Any")) {
            if(order.getInstrument() != getInstrument(symbol)) continue;
         }

         if(!comment.isEmpty()) {
            if(order.getComment().indexOf(comment) < 0) continue;
         }

         count++;
   }

   return count;
}

//------------------------------------------------------------------

private int sqGetBarsSinceOpen(String symbol, int magicNumber, int direction, String comment) throws JFException {
   order = sqGetOrderInHistory(magicNumber, symbol, direction, comment);	
	
   if(order!=null) {
		long opTime = order.getFillTime();

		int numberOfBars = 0;
		int limit = 1000;

		List<IBar> bars = history.getBars(selectedInstrument, selectedPeriod, OfferSide.BID, Filter.ALL_FLATS, limit, history.getStartTimeOfCurrentBar(selectedInstrument, selectedPeriod), 0);

		for(int i=0; i<bars.size(); i++) {
			if(opTime < bars.get(i).getTime()) {
				numberOfBars++;
			}
		}

		return numberOfBars;
   }

   return -1;
}

//------------------------------------------------------------------

private int sqGetBarsSinceClose(String symbol, int magicNumber, int direction, String comment) throws JFException {
   order = sqGetOrderInHistory(magicNumber, symbol, direction, comment);	
	
   if(order!=null) {
		long clTime = order.getCloseTime();

		int numberOfBars = 0;
		int limit = 1000;

		List<IBar> bars = history.getBars(selectedInstrument, selectedPeriod, OfferSide.BID, Filter.ALL_FLATS, limit, history.getStartTimeOfCurrentBar(selectedInstrument, selectedPeriod), 0);

		for(int i=0; i<bars.size(); i++) {
			if(clTime < bars.get(i).getTime()) {
				numberOfBars++;
			}
		}

		return numberOfBars;
   }

   return -1;
}

//------------------------------------------------------------------

private int sqGetLastOrderType(String symbol, int magicNumber, String comment) throws JFException {
   order = sqGetOrderInHistory(magicNumber, symbol, 0, comment);
	
   if(order!=null) {
	  orderType = order.getOrderCommand(); 
	   
	  if(orderType.isLong()) {
         return 1;
      } else {
         return -1;
      }
   }

   return 0;
}

//------------------------------------------------------------------

private IOrder sqGetOrderInHistory(int magicNumber, String symbol, int direction, String comment) throws JFException {
   orders = sqGetHistoryOrders(symbol);

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		 order = orders.get(cc);
		 orderType = order.getOrderCommand();

		 // skip pending orders
		 if(orderType.isConditional()) {
			continue;
		 }

		 if(direction != 0) {
            if(direction > 0 && !orderType.isLong()) continue;
            if(direction < 0 && !orderType.isShort()) continue;
		 }

		 if(magicNumber != 0) {
			if(!checkOrderMagicNumber(order, magicNumber)) continue;
		 }  
		 else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

		 if(!symbol.equals("Any")) {
			if(order.getInstrument() != getInstrument(symbol)) continue;
		 }

		 if(!comment.isEmpty()) {
			if(order.getComment().indexOf(comment) < 0) continue;
		 }

		// otherwise we found the order
		return order;
   }

   return null;
}

//------------------------------------------------------------------

private boolean sqTradeRecentlyClosed(String symbol, int magicNumber, boolean checkThisBar, boolean checkThisMinute) throws JFException {
   int ordersChecked = 0;

   long currentTimeMinutes = SQTime.getTimeMinutes(getCurrentTime());

   orders = sqGetHistoryOrders(symbol);

   for (int cc = orders.size() - 1; cc >= 0; cc--) {
		order = orders.get(cc);
		orderType = order.getOrderCommand();

		// skip pending orders
		if(orderType.isConditional()) {
			continue;
		}

		if(magicNumber != 0) {
			if(!checkOrderMagicNumber(order, magicNumber)) continue;
		}  
		else if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

		if(!symbol.equals("Any")) {
			if(order.getInstrument() != getInstrument(symbol)) continue;
		}

		ordersChecked++;
		if(ordersChecked > 10) {
			// check only the very last 10 orders
			break;
		}

		if(checkThisBar) {
			if(order.getCloseTime() >= getBarTime(symbol, 0, 0)) {
				// order finished this bar
				return true;
			}
		}

		if(checkThisMinute) {
		   long orderTimeMinutes = SQTime.getTimeMinutes(order.getCloseTime());

			if(currentTimeMinutes == orderTimeMinutes) {
				// order finished this minute
				return true;
			}
		}
   }

   return false;
}

//------------------------------------------------------------------

private double sqHighest(String symbol, int timeframe, AppliedPrice computedFrom, int period, int shift) throws JFException {
   double maxnum = -100000000;
   double val;

   for(int i=shift; i<shift+period; i++) {
      val = sqGetValue(symbol, timeframe, computedFrom, i);

      if(val > maxnum) {
         maxnum = val;
      }
   }

   return maxnum;
}

//------------------------------------------------------------------

private int sqHighestIndex(String symbol, int timeframe, AppliedPrice computedFrom, int period, int shift) throws JFException {
   double maxnum = -100000000;
   int index = 0;
   double val;

   for(int i=shift; i<shift+period; i++) {
      val = sqGetValue(symbol, timeframe, computedFrom, i);

      if(val > maxnum) {
         maxnum = val;
         index = i;
      }
   }

   return index;
}

//------------------------------------------------------------------

private double sqLowest(String symbol, int timeframe, AppliedPrice computedFrom, int period, int shift) throws JFException {
   double minnum = 100000000;
   double val;

   for(int i=shift; i<shift+period; i++) {
      val = sqGetValue(symbol, timeframe, computedFrom, i);

      if(val < minnum) {
         minnum = val;
      }
   }

   return minnum;
}

//------------------------------------------------------------------

private int sqLowestIndex(String symbol, int timeframe, AppliedPrice computedFrom, int period, int shift) throws JFException {
   double minnum = 100000000;
   int index = 0;
   double val;

   for(int i=shift; i<shift+period; i++) {
      val = sqGetValue(symbol, timeframe, computedFrom, i);

      if(val < minnum) {
         minnum = val;
         index = i;
      }
   }

   return index;
}

//-----------------------------------------------------------------

private double sqGetValue(String symbol, int timeframe, AppliedPrice computedFrom, int shift) throws JFException {
   double val = 0;
   
   switch(computedFrom) {
	 case OPEN: val = sqOpen(symbol, timeframe, shift); break;
	 case HIGH: val = sqHigh(symbol, timeframe, shift); break;
	 case LOW: val = sqLow(symbol, timeframe, shift); break;
	 case CLOSE: val = sqClose(symbol, timeframe, shift); break;
	 case MEDIAN_PRICE: val = (sqHigh(symbol, timeframe, shift)+sqLow(symbol, timeframe, shift))/2; break;
	 case TYPICAL_PRICE: val = (sqHigh(symbol, timeframe, shift)+sqLow(symbol, timeframe, shift)+sqClose(symbol, timeframe, shift))/3; break;
	 case WEIGHTED_CLOSE: val = (sqHigh(symbol, timeframe, shift)+sqLow(symbol, timeframe, shift)+sqClose(symbol, timeframe, shift)+sqClose(symbol, timeframe, shift))/4; break;
   }
   
   return roundValue(val);
}

//+------------------------------------------------------------------+

double sqDaily(String symbol, int tf, AppliedPrice computedFrom, int shift) throws JFException {
   return sqGetValue(symbol, 1440, computedFrom, shift);
}                

//+------------------------------------------------------------------+

double sqWeekly(String symbol, int tf, AppliedPrice computedFrom, int shift) throws JFException {
   return sqGetValue(symbol, 10080, computedFrom, shift);
}

//+------------------------------------------------------------------+

double sqMonthly(String symbol, int tf, AppliedPrice computedFrom, int shift) throws JFException {
   return sqGetValue(symbol, 43200, computedFrom, shift);
}

//------------------------------------------------------------------

private double getPointValue(Instrument instrument) throws JFException {
	double price = context.getUtils().convertPipToCurrency(instrument, context.getAccount().getCurrency());
	
	return price / instrument.getPipValue() * 100000d;
}

//------------------------------------------------------------------

private long getBarTime(String symbol, int timeframe, int shift) throws JFException {
	return getBar(symbol, timeframe, shift).getTime();
}

//------------------------------------------------------------------

private long getCurrentTime() throws JFException {
	return history.getStartTimeOfCurrentBar(selectedInstrument, selectedPeriod);
}

//------------------------------------------------------------------

private void sqManageOrderExpiration(IOrder order) throws JFException {
   int tempValue = 0;                                                           
   int barsOpen = 0;

   ticket = order.getLabel();
   orderType = order.getOrderCommand();
	
   // Stop/Limit Order Expiration
   if(orderType.isConditional()) {
      // handle only pending orders
      tempValue = sqGetOrderExpiration(ticket);
      if(tempValue > 0) {
         barsOpen = sqGetOpenBarsForOrder(order, tempValue+10);
		 
         if(barsOpen >= tempValue) {
            print("Order with ticket: ", ticket, " expired");
            sqDeletePendingOrder(order, "Expired, bars valid: " + tempValue);
         }
      }
   }
}

//------------------------------------------------------------------

private int sqGetOpenBarsForOrder(IOrder order, int expBarsPeriod) throws JFException {
   long opTime;

   if(!orderType.isConditional()) { //live order
       opTime = order.getFillTime();
   } else { //pending order
       opTime = sqGetGlobalLongVariable(ticket, "sqOrderOpenTime");
   }

   int numberOfBars = 0;
   int limit = expBarsPeriod + 10;
      
   List<IBar> bars = history.getBars(selectedInstrument, selectedPeriod, OfferSide.BID, Filter.ALL_FLATS, limit, history.getStartTimeOfCurrentBar(selectedInstrument, selectedPeriod), 0);

   for(int i=0; i<bars.size(); i++) {
      if(opTime < bars.get(i).getTime()) {
         numberOfBars++;
      }
   }

   return numberOfBars;
}
	
//------------------------------------------------------------------

private boolean sqEvaluateFuzzySignal(int conditionsCount, int minTrueConditions) {

	boolean signalValue = false;
  int trueConditionsCount = 0;
   
  if(minTrueConditions <= 0) {
  	minTrueConditions = 1;
  }
	    
	for(int i=0; i<conditionsCount; i++) {
		boolean value = cond[i];
				
		if(value) {
			trueConditionsCount++;
		}
				
		if(trueConditionsCount >= minTrueConditions) {
			signalValue = true;
			break;
		}
	}
			
	return signalValue;
}

//------------------------------------------------------------------

private boolean sqIsBarOpen() {
	return true;
}
	
//------------------------------------------------------------------
// -- SQTime
//------------------------------------------------------------------
static private class SQTime {
	/** The Constant formaterDateMinute. */
	private static final SimpleDateFormat formaterDateMinute = new SimpleDateFormat("yyyy.MM.dd HH:mm");

	private static final SimpleDateFormat formaterFullDateTime = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss.SSS");
	
	private static final SimpleDateFormat formaterFullDateMinute = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss");
	
	/** The Constant formaterDate. */
	private static final SimpleDateFormat formaterDate = new SimpleDateFormat("yyyy.MM.dd");

	private static Calendar cal = Calendar.getInstance();

	//------------------------------------------------------------------
	
	public static String toDateMinuteString(long datetime) {
		return formaterDateMinute.format(datetime);
	}

	//------------------------------------------------------------------

	public static String toFullDateMinuteString(long datetime) {
		return formaterFullDateMinute.format(datetime);
	}
	
	//------------------------------------------------------------------
	
	public static String toFullDateTimeString(long datetime) {
		return formaterFullDateTime.format(datetime);
	}

	//------------------------------------------------------------------

	public static String toDateString(long datetime) {
		return formaterDate.format(datetime);
	}
	
	//------------------------------------------------------------------
	
	public static int getDate(long datetime) {
		return (int) (datetime / 1000);
	}
	
	//------------------------------------------------------------------

	public static int getYear(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.YEAR);
	}
	
	//------------------------------------------------------------------
	
	public static int getMonth(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.MONTH) + 1;
	}
	
	//------------------------------------------------------------------
	
	public static int getDayOfWeek(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.DAY_OF_WEEK);
	}
	
	//------------------------------------------------------------------
	
	public static int getDay(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.DAY_OF_YEAR);
	}
	
	//------------------------------------------------------------------
	
	public static int getHour(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.HOUR_OF_DAY);
	}
	
	//------------------------------------------------------------------
	
	public static int getMinute(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.MINUTE);
	}
	
	//------------------------------------------------------------------
	
	public static int getSecond(long datetime) {
		cal.setTimeInMillis(datetime);
		return cal.get(Calendar.SECOND);
	}
	
	//------------------------------------------------------------------
	
	public static int getTime(long datetime) {
		return (int) (datetime % (24*60*60*1000L));
	}
	
	//------------------------------------------------------------------
	
	public static int getTime(int hour, int minute, int second) {
		return hour*60*60*1000 + minute*60*1000 + second*1000;
	}

	//------------------------------------------------------------------
	
	public static long getTimeMinutes(long datetime) {
		cal.setTimeInMillis(datetime);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		return cal.getTimeInMillis();
	}

	// ------------------------------------------------------------------------

	public static long correctDayEnd(long datetime) {
		return setTime(datetime, 23, 59, 59, 999);
	}

	// ------------------------------------------------------------------------

	public static long correctDayStart(long datetime) {
		return setTime(datetime, 0, 0, 0, 0);
	}

	// ------------------------------------------------------------------------

	public static long setHHMM(long datetime, String hhmm) {
		String[] parts = hhmm.split(":");
		int hours = Integer.parseInt(parts[0]);
		int minutes = Integer.parseInt(parts[1]);

		cal.setTimeInMillis(datetime);
		cal.set(Calendar.HOUR, hours);
		cal.set(Calendar.MINUTE, minutes);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		
		return cal.getTimeInMillis();
	}
	
	// ------------------------------------------------------------------------
	
	public static long setTime(long datetime, int hour, int minute, int second) {
		cal.setTimeInMillis(datetime);
		cal.set(Calendar.HOUR, hour);
		cal.set(Calendar.MINUTE, minute);
		cal.set(Calendar.SECOND, second);
		cal.set(Calendar.MILLISECOND, 0);
		
		return cal.getTimeInMillis();
	}

	// ------------------------------------------------------------------------

	public static long setTime(long datetime, int hour, int minute, int second, int miliseconds) {
		cal.setTimeInMillis(datetime);
		cal.set(Calendar.HOUR, hour);
		cal.set(Calendar.MINUTE, minute);
		cal.set(Calendar.SECOND, second);
		cal.set(Calendar.MILLISECOND, miliseconds);
				
		return cal.getTimeInMillis();
	}
	
	// ------------------------------------------------------------------------

	public static long setDayOfWeek(long datetime, int value) {
		cal.setTimeInMillis(datetime);
		cal.set(Calendar.DAY_OF_WEEK, value);
		
		return cal.getTimeInMillis();
	}
	
	// ------------------------------------------------------------------------
	
	public static long addDays(long datetime, int day) {
		cal.setTimeInMillis(datetime);
		cal.add(Calendar.DATE, 1);
		
		return cal.getTimeInMillis();
	}

}

//------------------------------------------------------------------
// -- ITradingOption
//------------------------------------------------------------------
public interface ITradingOption {
	public boolean onTick() throws JFException;
}
	
//------------------------------------------------------------------

private double roundValue(double value){
    return round(value + 0.0000000001, 6);
}

//------------------------------------------------------------------

private int sqFixRanges(int value, int min, int max, int defaultVal) {
   if(value < min || value > max) {
      return defaultVal;
   }
   
   return value;
}

//------------------------------------------------------------------

private Object[] calculateIndicator(String functionName, String symbol, int timeframe, AppliedPrice applied_price, int shift, Object... params) throws JFException {
	try {
		instrument = this.getInstrument(symbol);
		period = this.getPeriod(timeframe);

		return this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, shift);
	} catch(Exception e) {
        throw new JFException(String.format("Failed to calculate indicator '%s'. " + e.getMessage(), functionName), e);
    }
}

//------------------------------------------------------------------

private Double calculateIndicatorValue(String functionName, String symbol, int timeframe, AppliedPrice applied_price, int shift, Object... params) throws JFException {
	try {
		instrument = this.getInstrument(symbol);
		period = this.getPeriod(timeframe);

		//return (Double)this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, shift)[0];
		return roundValue(((double[]) this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, Filter.ALL_FLATS, shift+1, history.getStartTimeOfCurrentBar(instrument, period), 0)[0])[0]);
	} catch(Exception e) {
        throw new JFException(String.format("Failed to calculate indicator '%s'. " + e.getMessage(), functionName), e);
    }
}

//------------------------------------------------------------------

private Double calculateIndicatorLineValue(String functionName, String symbol, int timeframe, AppliedPrice applied_price, int line, int shift, Object... params) throws JFException {
	try {
		instrument = this.getInstrument(symbol);
		period = this.getPeriod(timeframe);

		//return (Double)this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, shift)[0];
		return roundValue(((double[]) this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, Filter.ALL_FLATS, shift+1, history.getStartTimeOfCurrentBar(instrument, period), 0)[line])[0]);
	} catch(Exception e) {
        throw new JFException(String.format("Failed to calculate indicator '%s'. " + e.getMessage(), functionName), e);
    }
}

//------------------------------------------------------------------

private Double calculateIndicatorLineValue(String functionName, String symbol, int timeframe, OfferSide[] offerSides, IIndicators.AppliedPrice[] inputTypes, int line, int shift, Object... params) throws JFException {
	try {
		instrument = this.getInstrument(symbol);
		period = this.getPeriod(timeframe);

		//return (Double)this.indicators.calculateIndicator(instrument, period, new OfferSide[] {OfferSide.BID}, functionName, new IIndicators.AppliedPrice[] {applied_price}, params, shift)[0];
		return roundValue(((double[]) this.indicators.calculateIndicator(instrument, period, offerSides, functionName, inputTypes, params, Filter.ALL_FLATS, shift+1, history.getStartTimeOfCurrentBar(instrument, period), 0)[line])[0]);
	} catch(Exception e) {
        throw new JFException(String.format("Failed to calculate indicator '%s'. " + e.getMessage(), functionName), e);
    }
}

//------------------------------------------------------------------

private IBar getBar(String symbol, int timeframe, int shift) throws JFException {
	instrument = this.getInstrument(symbol);
	period = this.getPeriod(timeframe);
	
    return history.getBars(instrument, period, OfferSide.BID, Filter.ALL_FLATS, shift+1, history.getStartTimeOfCurrentBar(instrument, period), 0).get(0);
}

//------------------------------------------------------------------

private double sqBarRange(String symbol, int timeframe, int shift) throws JFException {
	bar = getBar(symbol, timeframe, shift);
	
	return roundValue(bar.getHigh() - bar.getLow());
}

//------------------------------------------------------------------+

private double sqOpen(String symbol, int timeframe, int shift) throws JFException {
	bar = getBar(symbol, timeframe, shift);
	
	return bar.getOpen();
}   

//------------------------------------------------------------------

private double sqHigh(String symbol, int timeframe, int shift) throws JFException {
	bar = getBar(symbol, timeframe, shift);
	
	return bar.getHigh();
}

//------------------------------------------------------------------

private double sqLow(String symbol, int timeframe, int shift) throws JFException {
	bar = getBar(symbol, timeframe, shift);
	
	return bar.getLow();
}

//------------------------------------------------------------------

private double sqClose(String symbol, int timeframe, int shift) throws JFException {
	bar = getBar(symbol, timeframe, shift);
	
	return bar.getClose();
}

//------------------------------------------------------------------

private double sqBiggestRange(String symbol, int timeframe, int period, int shift) throws JFException {
   double maxnum = -100000000;
   double range;

   for(int i=shift; i<shift+period; i++) {
      range = sqHigh(symbol, timeframe, i) - sqLow(symbol, timeframe, i);

      if(range > maxnum) {
         maxnum = range;
      }
   }

   return roundValue(maxnum);
}

//------------------------------------------------------------------

private double sqSmallestRange(String symbol, int timeframe, int period, int shift) throws JFException {
   double minnum = 100000000;
   double range;

   for(int i=shift; i<shift+period; i++) {
      range = sqHigh(symbol, timeframe, i) - sqLow(symbol, timeframe, i);

      if(range < minnum) {
         minnum = range;
      }
   }

   return roundValue(minnum);
}

//------------------------------------------------------------------

private double sqRSI(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("rsi", symbol, timeframe, applied_price, shift, period);
}

//------------------------------------------------------------------

private double sqCCI(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("cci", symbol, timeframe, applied_price, shift, period);
}

//------------------------------------------------------------------

private double sqMA(String symbol, int timeframe, int ma_period, int ma_shift, int ma_method, AppliedPrice applied_price, int shift) throws JFException {
   ma_method = sqFixRanges(ma_method, 0, 3, 0);
      
   switch(ma_method) {
      case MODE_SMA: return this.calculateIndicatorValue("SMA", symbol, timeframe, applied_price, shift, ma_period);
      case MODE_EMA: return this.calculateIndicatorValue("EMA", symbol, timeframe, applied_price, shift, ma_period);
      case MODE_SMMA: return this.calculateIndicatorValue("SMMA", symbol, timeframe, applied_price, shift, ma_period);
      case MODE_LWMA: return this.calculateIndicatorValue("LWMA", symbol, timeframe, applied_price, shift, ma_period);
   }

   return -1d;
}

//------------------------------------------------------------------

private double sqHullMovingAverage(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("hma", symbol, timeframe, applied_price, shift, period);
}

//+------------------------------------------------------------------+

private  double sqTEMA(String symbol, int timeframe, int ma_period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("tema", symbol, timeframe, applied_price, shift, ma_period);
}

//+------------------------------------------------------------------+

private  double sqKama(String symbol, int timeframe, int timePeriod, int fastMAPeriod, int slowMAPeriod, int shift) throws JFException {
   return this.calculateIndicatorValue("kama", symbol, timeframe, MEDIAN_PRICE, shift, timePeriod, fastMAPeriod, slowMAPeriod);
}

//+------------------------------------------------------------------+

private  double sqIchimoku(String symbol, int timeframe, int tenkanPeriod, int kijunPeriod, int senkouPeriod, int line, int shift) throws JFException {
   //dukas doc - outputs are returned in the following order: 'Tenkan Sen', 'Ki-jun Sen', 'Chinkou Span', 'Senkou A', 'Senkou B', 'Cloud(Senkou A)', 'Cloud(Senkou B)'
   if(line==2) {
		line = 3;
   } else if(line==3) {
		line = 4;
   }	
   
   return this.calculateIndicatorLineValue("ichimoku", symbol, timeframe, null, line, shift, tenkanPeriod, kijunPeriod, senkouPeriod);
}

//+------------------------------------------------------------------+

private  double sqAroon(String symbol, int timeframe, int period, int line, int shift) throws JFException {
   //dukas doc - outputs are returned in the following order: 'Aroon Down', 'Aroon Up'
   if(line==0) {
		line = 1;
   } else if(line==1) {
		line = 0;
   }
   return this.calculateIndicatorLineValue("aroon", symbol, timeframe, null, line, shift, period);
}

//------------------------------------------------------------------

private double sqADX(String symbol, int timeframe, int period, int line, int shift) throws JFException {
	return this.calculateIndicatorLineValue("dmi", symbol, timeframe, null, line, shift, period);
}

private double sqATR(String symbol, int timeframe, int period, int shift) throws JFException {
	return this.calculateIndicatorValue("atr", symbol, timeframe, null, shift, period);
}

//------------------------------------------------------------------

private double sqAO(String symbol, int timeframe, int shift) throws JFException {
   return this.calculateIndicatorLineValue("awesome2", symbol, timeframe, MEDIAN_PRICE, 0, shift, 5, 0, 34, 0);
}

//------------------------------------------------------------------

private double sqBearsPower(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("bearp", symbol, timeframe, applied_price, shift, period);
}

//+------------------------------------------------------------------

private double sqBullsPower(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("bullp", symbol, timeframe, applied_price, shift, period);
}

//------------------------------------------------------------------

private double sqDeMarker(String symbol, int timeframe, int period, int shift) throws JFException {
   return this.calculateIndicatorLineValue("td_i", symbol, timeframe, null, 0, shift, period);
}

//------------------------------------------------------------------

private double sqMACD(String symbol, int timeframe, int fast_ema_period, int slow_ema_period, int signal_period, AppliedPrice applied_price, int mode, int shift) throws JFException {
   return this.calculateIndicatorLineValue("macd", symbol, timeframe, applied_price, mode, shift, fast_ema_period, slow_ema_period, signal_period);
} 

//+------------------------------------------------------------------+

private double sqMomentum(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("mom", symbol, timeframe, applied_price, shift, period);
}

//----------------------------------------------------------------------------

private double sqLinReg(String symbol, int timeframe, int period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("linearReg", symbol, timeframe, applied_price, shift, period);
}

//------------------------------------------------------------------

private double sqPivots(String symbol, int timeframe, int startHour, int startMinute, int line, int shift) throws JFException {
   //SQ    P, R1, R2, R3, S1, S2, S3 
   //jforex P, R1, S1, R2, S2, R3, S3
	
   switch(line) {
      case 2: line = 3; break; //R2
      case 3: line = 5; break; //R3
	  case 4: line = 2; break; //S1
	  case 5: line = 4; break; //S2
   }
	
   return this.calculateIndicatorLineValue("pivot2", symbol, timeframe, null, line, shift);
}

//------------------------------------------------------------------

private double sqFibo(String symbol, int timeframe, int fiboRange, double fiboLevel) throws JFException {
   int line = 0;  //jforex P, R1, S1, R2, S2, R3, S3
   //todo - compute line from fiboLevel parameter

   return this.calculateIndicatorLineValue("fibPivot2", symbol, timeframe, null, line, 0);
}

//------------------------------------------------------------------

private double sqKeltnerChannel(String symbol, int timeframe, int period, double deviation, int line, int shift) throws JFException {
   if(line==1) line = 2; //dukas doc - outputs are returned in the following order: 'Keltner Channel Up', 'Keltner Channel Middle', 'Keltner Channel Low'
   //return this.calculateIndicatorLineValue("keltner", symbol, timeframe, null, line, shift, period);
   return this.calculateIndicatorLineValue("kbands", symbol, timeframe, new OfferSide[] {OfferSide.BID, OfferSide.BID}, new IIndicators.AppliedPrice[] {TYPICAL_PRICE, TYPICAL_PRICE}, line, shift, period, period, deviation);
}

//----------------------------------------------------------------------------

private double sqWPR(String symbol, int timeframe, int period, int shift) throws JFException {
   return this.calculateIndicatorValue("willr", symbol, timeframe, null, shift, period);
}

//------------------------------------------------------------------

private double sqStochastic(String symbol, int timeframe, int Kperiod, int Dperiod, int slowing, int method, int price_field, int mode, int shift) throws JFException {
   price_field = sqFixRanges(price_field, 0, 1, 0);
   method = sqFixRanges(method, 0, 3, 0);
   
   //return this.calculateIndicatorLineValue("stochP", symbol, timeframe, null, mode, shift, Kperiod, slowing, method, Dperiod, method, price_field);
   return this.calculateIndicatorLineValue("stoch", symbol, timeframe, null, mode, shift, Kperiod, slowing, method, Dperiod, method);
} 

private double sqOsMA(String symbol, int timeframe, int fast_ema_period, int slow_ema_period, int signal_period, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("osma", symbol, timeframe, applied_price, shift, fast_ema_period, slow_ema_period, signal_period);
}

//------------------------------------------------------------------

private double sqBands(String symbol, int timeframe, int period, double deviation, int bands_shift, AppliedPrice applied_price, int mode, int shift) throws JFException {
   if(mode==1) mode = 2; //dukas doc - outputs are returned in the following order: 'Upper Band', 'Middle Band', 'Lower Band'
   return this.calculateIndicatorLineValue("bbands", symbol, timeframe, applied_price, mode, shift, period, deviation, deviation, 0);
}

//------------------------------------------------------------------

private double sqBBWidthRatio(String symbol, int timeframe, int period, double deviation, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorLineValue("bbandwidth", symbol, timeframe, applied_price, 0, shift, period, deviation);
}

//------------------------------------------------------------------

private  double sqBBRange(String symbol, int timeframe, int period, double deviation, AppliedPrice applied_price, int shift) throws JFException {
   return roundValue(sqBands(symbol, timeframe, period, deviation, 0, applied_price, 1, shift) - sqBands(symbol, timeframe, period, deviation, 0, applied_price, 2, shift));
}

//------------------------------------------------------------------

private double sqSAR(String symbol, int timeframe, double step, double maximum, int shift) throws JFException {
   return this.calculateIndicatorValue("sar", symbol, timeframe, null, shift, step, maximum);
}

//------------------------------------------------------------------

private double sqStdDev(String symbol, int timeframe, int ma_period, int ma_shift, int ma_method, AppliedPrice applied_price, int shift) throws JFException {
   return this.calculateIndicatorValue("stdDev", symbol, timeframe, applied_price, shift, ma_period, 0);
}

//------------------------------------------------------------------

private double sqFractal(String symbol, int timeframe, int fractal, int bufferIndex, int shift) throws JFException {
   return this.calculateIndicatorLineValue("fractal", symbol, timeframe, null, bufferIndex, shift, fractal);
}

//----------------------------------------------------------------------------

private double sqIndicatorHighest(int period, int nthValue, String indicatorIdentification) throws JFException {
   if(period > 1000) {
        print("Period used for sqIndicatorHighest function is too high. Max value is 1000");
        period = 1000;
   }
   
   if(nthValue < 0 || nthValue >= period) {
	   return(-1);
   }
   
   Double[] indicatorValues = new Double[1000];
   int i;

   for(i=0; i<1000; i++) {
      indicatorValues[i] = -2147483647d;
   }

   for(i=0; i<period; i++) {
      indicatorValues[i] = sqGetIndicatorByIdentification(indicatorIdentification, i);
   }

   Arrays.sort(indicatorValues, Comparator.reverseOrder());

   if(nthValue < 0 || nthValue >= period) {
      return(-1);
   }

   return indicatorValues[nthValue];
}

//----------------------------------------------------------------------------

private double sqIndicatorLowest(int period, int nthValue, String indicatorIdentification) throws JFException {      
   if(period > 1000) {
        print("Period used for sqIndicatorLowest function is too high. Max value is 1000");
        period = 1000;
   }
   
   if(nthValue < 0 || nthValue >= period) {
	   return(-1);
   }
   
   Double[] indicatorValues = new Double[1000];
   int i;

   for(i=0; i<1000; i++) {
      indicatorValues[i] = 2147483647d;
   }

   for(i=0; i<period; i++) {
      indicatorValues[i] = sqGetIndicatorByIdentification(indicatorIdentification, i);
   }

   Arrays.sort(indicatorValues);

   if(nthValue < 0 || nthValue >= period) {
      return(-1);
   }

   return indicatorValues[nthValue];
}

//----------------------------------------------------------------------------

private double sqIndicatorAverage(int period, int maMethod, String indicatorIdentification) throws JFException {
	//todo Moving Average method (SMA, EMA, SMMA, LWMA)
   double sum = 0;
	
   for(int i=0; i<period; i++) {
      sum+= sqGetIndicatorByIdentification(indicatorIdentification, i);
   }

   return roundValue(sum / period);
}

//----------------------------------------------------------------------------

private boolean sqIsRising(String indicatorIdentification, int bars, boolean allowSameValues, int shift) throws JFException {
   boolean atLeastOnce = false;

   double previousValue = round(sqGetIndicatorByIdentification(indicatorIdentification, bars+shift-1), 6);

   for(int i=1; i<bars; i++) {
      double currentValue = round(sqGetIndicatorByIdentification(indicatorIdentification, bars+shift-1-i), 6);

      if(currentValue < previousValue) {
         // indicator was falling
         return false;
      }
      if(currentValue == previousValue && allowSameValues == false) {
         // indicator was the same, not allowed
         return false;
      }
      if(currentValue > previousValue) {
         atLeastOnce = true;
      }

      previousValue = currentValue;
   }

   // indicator was not rising once
   return atLeastOnce;
}

//----------------------------------------------------------------------------

private boolean sqIsFalling(String indicatorIdentification, int bars, boolean allowSameValues, int shift) throws JFException {
   boolean atLeastOnce = false;

   double previousValue = round(sqGetIndicatorByIdentification(indicatorIdentification, bars+shift-1), 6);

   for(int i=1; i<bars; i++) {
      double currentValue = round(sqGetIndicatorByIdentification(indicatorIdentification, bars+shift-1-i), 6);

      if(currentValue > previousValue) {
         // indicator was rising
         return false;
      }
      if(currentValue == previousValue && allowSameValues == false) {
         // indicator was the same, not allowed
         return false;
      }
      if(currentValue < previousValue) {
         atLeastOnce = true;
      }

      previousValue = currentValue;
   }

   // indicator was not falling once
   return atLeastOnce;
}

//------------------------------------------------------------------

private double sqHeikenAshi(String symbol, int timeframe, AppliedPrice mode, int shift) throws JFException {
	if(mode == OPEN) 	return roundValue(sqHeikenAshi(symbol, timeframe, 0, shift));
	if(mode == CLOSE)	return roundValue(sqHeikenAshi(symbol, timeframe, 1, shift));
	if(mode == HIGH)	return roundValue(Math.max(sqHeikenAshi(symbol, timeframe, 2, shift), sqHeikenAshi(symbol, timeframe, 3, shift)));
	if(mode == LOW)		return roundValue(Math.min(sqHeikenAshi(symbol, timeframe, 2, shift), sqHeikenAshi(symbol, timeframe, 3, shift)));

   return -1;
}

//------------------------------------------------------------------

private double sqAvgVolume(String symbol, int timeframe, int period, int shift) throws JFException {
   return this.calculateIndicatorValue("sqAvgVolume", symbol, timeframe, null, shift, period);
}

//------------------------------------------------------------------

private double sqHeikenAshi(String symbol, int timeframe, int line, int shift) throws JFException {
	 return this.calculateIndicatorLineValue("heikinAshiLines", symbol, timeframe, null, line, shift);
}

//------------------------------------------------------------------
// Candle Pattern functions
//------------------------------------------------------------------

private boolean sqBearishEngulfing(String symbol, int timeframe, int shift) throws JFException {
   double O = sqOpen(symbol, timeframe, shift);
   double O1 = sqOpen(symbol, timeframe, shift+1);
   double C = sqClose(symbol, timeframe, shift);
   double C1 = sqClose(symbol, timeframe, shift+1);

   double ocDiff = roundValue(O-C);
   double o1c1Diff = roundValue(C1-O1);

   if ((C1>O1)&&(O>C)&&(O>=C1)&&(O1>=C)&&(ocDiff>o1c1Diff)) {
      return true;
   }

   return false;
}

//------------------------------------------------------------------

private boolean sqBullishEngulfing(String symbol, int timeframe, int shift) throws JFException {
   double O = sqOpen(symbol, timeframe, shift);
   double O1 = sqOpen(symbol, timeframe, shift+1);
   double C = sqClose(symbol, timeframe, shift);
   double C1 = sqClose(symbol, timeframe, shift+1);

   double coDiff = roundValue(C-O);
   double o1c1Diff = roundValue(O1-C1);
   
   if ((O1>C1)&&(C>O)&&(C>=O1)&&(C1>=O)&&(coDiff>o1c1Diff)) {
      return true;
   }

   return false;
}

//------------------------------------------------------------------

private boolean sqDarkCloudCover(String symbol, int timeframe, int shift) throws JFException {
   instrument = this.getInstrument(symbol);
   
   double L = sqLow(symbol, timeframe, shift);
   double H = sqHigh(symbol, timeframe, shift);

   double O = sqOpen(symbol, timeframe, shift);
   double O1 = sqOpen(symbol, timeframe, shift+1);
   double C = sqClose(symbol, timeframe, shift);
   double C1 = sqClose(symbol, timeframe, shift+1);
   
 	double tickSize = instrument.getPipValue();

 	double Piercing_Line_Ratio = 0.5f;
 	double Piercing_Candle_Length = 10.0f;
 	
 	double HL = roundValue(H-L);
 	double OC = roundValue(O-C);
 	double OC_HL = HL != 0 ? roundValue(OC/HL) : 0;
 	double O1C1_D2 = roundValue((O1+C1)/2);
 	double PCL_MTS = roundValue(Piercing_Candle_Length*tickSize);
 			
 	if(C1 > O1 && O1C1_D2 > C && O > C && C > O1 && OC_HL > Piercing_Line_Ratio && HL >= PCL_MTS) {
 		return true;
 	}

   return false;
}

//------------------------------------------------------------------

private boolean sqDoji(String symbol, int timeframe, int shift) throws JFException {
   instrument = this.getInstrument(symbol);
   
   double diff = roundValue(Math.abs(sqOpen(symbol, timeframe, shift) - sqClose(symbol, timeframe, shift)));
   double coef = roundValue(instrument.getPipValue() * 0.6); 
   
   if(diff < coef) {
      return true;
   }
   
   return false;
}

//------------------------------------------------------------------

private boolean sqHammer(String symbol, int timeframe, int shift) throws JFException {
   instrument = this.getInstrument(symbol);
   
   double H = sqHigh(symbol, timeframe, shift);
   double L = sqLow(symbol, timeframe, shift);
   double L1 = sqLow(symbol, timeframe, shift+1);
   double L2 = sqLow(symbol, timeframe, shift+2);
   double L3 = sqLow(symbol, timeframe, shift+3);

   double O = sqOpen(symbol, timeframe, shift);
   double C = sqClose(symbol, timeframe, shift);
   double CL = H-L;

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = roundValue(BodyLow - L);
   double UW = roundValue(H - BodyHigh);
   double BLa = roundValue(Math.abs(O - C));
   double BL90 = roundValue(BLa * Candle_WickBody_Percent);
   
   double pipValue = instrument.getPipValue();
   
   double LW_D2 = roundValue(LW / 2);
   double LW_D3 = roundValue(LW / 3);
   double LW_D4 = roundValue(LW / 4);
   double BL90_M2 = roundValue(2 * BL90);
   double CL_MPV = roundValue(CandleLength * pipValue);
     
   if(L <= L1 && L < L2 && L < L3)  {
 		if(LW_D2 > UW && LW > BL90_M2 && CL >= CL_MPV && O != C && LW_D3 <= UW && LW_D4 <= UW)  {
    	  	return true;
      }
      if(LW_D3 > UW && LW > BL90_M2 && CL >= CL_MPV && O != C && LW_D4 <= UW)  {
      	return true;
      }
      if(LW_D4 > UW && LW > BL90_M2 && CL >= CL_MPV && O != C)  {
    	  	return true;
      }
   }
   
   return false;
}

//------------------------------------------------------------------

private boolean sqPiercingLine(String symbol, int timeframe, int shift) throws JFException {
   instrument = this.getInstrument(symbol);
   
   double L = sqLow(symbol, timeframe, shift);
   double H = sqHigh(symbol, timeframe, shift);

   double O = sqOpen(symbol, timeframe, shift);
   double O1 = sqOpen(symbol, timeframe, shift+1);
   double C = sqClose(symbol, timeframe, shift);
   double C1 = sqClose(symbol, timeframe, shift+1);
   
 	double tickSize = instrument.getPipValue();

 	double Piercing_Line_Ratio = 0.5f;
 	double Piercing_Candle_Length = 10.0f;
 	
 	double HL = roundValue(H-L);
 	double CO = roundValue(C-O);
 	double CO_HL = HL != 0 ? roundValue(CO/HL) : 0;
 	double O1C1_D2 = roundValue((O1+C1)/2);
 	double PCL_MTS = roundValue(Piercing_Candle_Length*tickSize);
 			
 	if(C1 < O1 && O1C1_D2 < C && O < C && C < O1 && CO_HL > Piercing_Line_Ratio && HL >= PCL_MTS) {
 		return true;
 	}

   return false;
}

//------------------------------------------------------------------

private boolean sqShootingStar(String symbol, int timeframe, int shift) throws JFException {
   instrument = this.getInstrument(symbol);
   
   double L = sqLow(symbol, timeframe, shift);
   double H = sqHigh(symbol, timeframe, shift);
   double H1 = sqHigh(symbol, timeframe, shift + 1);
   double H2 = sqHigh(symbol, timeframe, shift + 2);
   double H3 = sqHigh(symbol, timeframe, shift + 3);

   double O = sqOpen(symbol, timeframe, shift);
   double C = sqClose(symbol, timeframe, shift);
   double CL = roundValue(H - L);

   double BodyLow, BodyHigh;
   double Candle_WickBody_Percent = 0.9;
   double CandleLength = 12;

   if (O > C) {
      BodyHigh = O;
      BodyLow = C;
   } else {
      BodyHigh = C;
      BodyLow = O;
   }

   double LW = roundValue(BodyLow - L);
   double UW = roundValue(H - BodyHigh);
   double BLa = roundValue(Math.abs(O - C));
   double BL90 = roundValue(BLa * Candle_WickBody_Percent);
   
   double pipValue = instrument.getPipValue();
   
   double UW_D2 = roundValue(UW / 2);
   double UW_D3 = roundValue(UW / 3);
   double UW_D4 = roundValue(UW / 4);
   double BL90_M2 = roundValue(2 * BL90);
   double CL_MPV = roundValue(CandleLength * pipValue);

   if(H >= H1 && H > H2 && H > H3)  {
      if(UW_D2 > LW && UW > BL90_M2 && CL >= CL_MPV && O != C && UW_D3 <= LW && UW_D4 <= LW)  {
         return true;
      }
      if(UW_D3 > LW && UW > BL90_M2 && CL >= CL_MPV && O != C && UW_D4 <= LW)  {
         return true;
      }
      if(UW_D4 > LW && UW > BL90_M2 && CL >= CL_MPV && O != C)  {
         return true;
      }
   }

   return false;
} 
	


//------------------------------------------------------------------
// -- CExitAtEndOfDay
//------------------------------------------------------------------
private class  CExitAtEndOfDay implements ITradingOption {
	private long dailyEODExitTime;
	private long EODTime;
	private boolean closedThisDay;

	public CExitAtEndOfDay() {
		dailyEODExitTime = -1;
		EODTime = -1;
		closedThisDay = false;
	}

	//------------------------------------------------------------------------

	@Override
	public boolean onTick() throws JFException {
		if(!ExitAtEndOfDay) {
			return true;
		}                   

		long currentTime = getCurrentTime();

		if(currentTime > EODTime) {
			//it is a new day
			initTimesForCurrentDay(currentTime);
		}

		checkOrders();

		if(currentTime >= dailyEODExitTime) {
			// returning false means there will be no more processing on this tick
			// this is what we want because we don't want to be trading after close of all positions
			return false; 
		}

		return true;
	}     

	//------------------------------------------------------------------------

	private void checkOrders() throws JFException {
		long currentTime = getCurrentTime();
		long currentTimeDayStart = SQTime.correctDayStart(currentTime);    
		long currentTimeDayEnd = SQTime.correctDayEnd(currentTime);

		if(!closedThisDay && currentTime >= dailyEODExitTime) {
			orders = engine.getOrders();
			for (int cc = 0; cc < orders.size(); cc++) {
				order = orders.get(cc);
				orderType = order.getOrderCommand();

				if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

				boolean isLiveOrder = !orderType.isConditional();

				//Close all orders at the end of a day. When there is a data gap, on the first tick of new day close all pending orders and orders filled before current day start
				if(currentTimeDayEnd == EODTime || !isLiveOrder || order.getFillTime() < currentTimeDayStart) {
					if(isLiveOrder){
						sqClosePositionAtMarket(order, 0, "End Of Day");
					} else {
						sqDeletePendingOrder(order, "End Of Day");
					}
				}
			}

			closedThisDay = true;
		}  
	}

	//------------------------------------------------------------------------

	private void initTimesForCurrentDay(long currentTime) {
		// set end time of the current day (so that we now when new day starts)
		EODTime = SQTime.correctDayEnd(currentTime);

		// set time of EOD
		if(DayExitTime.equals("00:00") || DayExitTime.equals("0:00")){
			dailyEODExitTime = EODTime;
		} else {
			dailyEODExitTime = SQTime.setHHMM(currentTime, DayExitTime);
		}

		closedThisDay = false;
	}
}

// create variable for class instance (required)
private CExitAtEndOfDay objExitAtEndOfDay = new CExitAtEndOfDay();




//------------------------------------------------------------------
// -- CExitOnFriday
//------------------------------------------------------------------
private class  CExitOnFriday implements ITradingOption {
	private long thisFridayExitTime; 
	private long thisSundayBeginTime;
	private long EOFDayTime;
	private boolean closedThisWeek;

	public CExitOnFriday() {
		thisFridayExitTime = -1;    
		thisSundayBeginTime = -1;
		closedThisWeek = false;
	}

	//------------------------------------------------------------------------

	@Override
	public boolean onTick() throws JFException {
		if(!ExitOnFriday) {
			return true;
		}

		long currentTime = getCurrentTime();

		if(thisFridayExitTime < 0) {
			initFridayExitTime(currentTime, 0);
		}

		checkOrders();

		if(currentTime < thisFridayExitTime) {
			// trade normally
			return true;
		}

		if(currentTime < thisSundayBeginTime) {
			// do not allow opening new positions until sunday.
			// returning false means there will be no more processing on this tick.
			// this is what we want because we don't want to be trading after close of all positions
			return false;
		} else {
			// new week starting
			initFridayExitTime(currentTime, SQTime.getDayOfWeek(currentTime) == 0 ? 1 : 0); 

			return true;
		}
	}           

	//------------------------------------------------------------------------

	private void checkOrders() throws JFException {
		long currentTime = getCurrentTime();      
		long currentTimeDayStart = SQTime.correctDayStart(currentTime);      
		long currentTimeDayEnd = SQTime.correctDayEnd(currentTime);

		if(!closedThisWeek && currentTime >= thisFridayExitTime) {
			// time is over friday closing time, we should close the positions
			orders = engine.getOrders();
			for (int cc = 0; cc < orders.size(); cc++) {
				order = orders.get(cc);
				orderType = order.getOrderCommand();

				if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

				boolean isLiveOrder = !orderType.isConditional();

				//Close all orders at the end of Friday. When there is a data gap, on the first tick of new day close all pending orders and orders filled before current day start
				if(currentTimeDayEnd == EOFDayTime || !isLiveOrder || order.getFillTime() < currentTimeDayStart) {
					if(isLiveOrder){
						sqClosePositionAtMarket(order, 0, "End Of Friday");
					} else {
						sqDeletePendingOrder(order, "End Of Friday");
					}
				}
			}

			closedThisWeek = true;
		} 
	}

	//------------------------------------------------------------------------

	private void initFridayExitTime(long currentTime, int addDays) {
		if(addDays > 0) {
			thisFridayExitTime = SQTime.addDays(currentTime, addDays);
		} else {
			thisFridayExitTime = currentTime;
		}

		// set time of EOD 
		thisFridayExitTime = SQTime.setDayOfWeek(thisFridayExitTime, (FridayExitTime.equals("00:00") || FridayExitTime.equals("0:00")) ? Calendar.SATURDAY : Calendar.FRIDAY);
		thisFridayExitTime = SQTime.setHHMM(thisFridayExitTime, FridayExitTime);	

		EOFDayTime = SQTime.correctDayEnd(thisFridayExitTime);

		thisSundayBeginTime = SQTime.setDayOfWeek(currentTime, Calendar.SUNDAY);
		thisSundayBeginTime = SQTime.correctDayStart(thisSundayBeginTime);

		closedThisWeek = false;
	}
}

// create variable for class instance (required)
private CExitOnFriday objExitOnFriday = new CExitOnFriday();

//------------------------------------------------------------------
// -- CLimitTimeRange
//------------------------------------------------------------------
private class  CLimitTimeRange implements ITradingOption {
	private long EODTime;
	private long dailySignalTimeRangeFrom;
	private long dailySignalTimeRangeTo;
	private boolean closedThisDay;

	public CLimitTimeRange() {
		EODTime = -1;
		closedThisDay = false;
	}

	//------------------------------------------------------------------------

	@Override
	public boolean onTick() throws JFException {
		if(!LimitSignalsTimeRange) {
			return true;
		}

		long currentTime = getCurrentTime();

		if(currentTime > EODTime) {
			// it is new day
			initTimesForCurrentDay(currentTime);
		}

		checkOrders();

		if(currentTime < dailySignalTimeRangeFrom || currentTime >= dailySignalTimeRangeTo) {
			// time is outside given range
			// returning false means there will be no more processing on this tick
			// this is what we want because we don't want to be trading outside of this time range

			return false; 
		}

		return true;
	}

	//------------------------------------------------------------------------

	private void checkOrders() throws JFException {
		long currentTime = getCurrentTime();
		if(!closedThisDay && ExitAtEndOfRange && currentTime >= dailySignalTimeRangeTo) {
			orders = engine.getOrders();
			for (int cc = 0; cc < orders.size(); cc++) {
				order = orders.get(cc);
				orderType = order.getOrderCommand();

				if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

				if(!orderType.isConditional()) {
					sqClosePositionAtMarket(order, 0, "End Of Range");
				} else {
					sqDeletePendingOrder(order, "End Of Range");
				}
			}

			closedThisDay = true;
		}
	}

	//------------------------------------------------------------------------

	private void initTimesForCurrentDay(long currentTime) {
		// set end time of the current day (so that we now when new day starts)
		EODTime = SQTime.correctDayEnd(currentTime);

		// set time of range open 
		dailySignalTimeRangeFrom = SQTime.setHHMM(currentTime, SignalTimeRangeFrom);

		dailySignalTimeRangeTo = SQTime.setHHMM(currentTime, SignalTimeRangeTo);    
		closedThisDay = false;
	}
}


// create variable for class instance (required)
private CLimitTimeRange objLimitTimeRange = new CLimitTimeRange();


//------------------------------------------------------------------
// -- CMaxTradesPerDay
//------------------------------------------------------------------
private class  CMaxTradesPerDay implements ITradingOption {
	private int lastHistoryPositionChecked;
	private long openTimeToday;
	private long EODTime;
	private boolean reachedLimitToday;

	public CMaxTradesPerDay() {
		EODTime = -1;
		lastHistoryPositionChecked = 0;
	}

	//------------------------------------------------------------------------

	@Override
	public boolean onTick() throws JFException {
		if(MaxTradesPerDay <= 0) {
			return true;
		}

		long currentTime = getCurrentTime();

		if(currentTime > EODTime) {
			// it is new day
			initTimeForCurrentDay(currentTime);
		}		

		if(reachedLimitToday) {
			return false;
		}

		if(getNumberOfTradesToday() >= MaxTradesPerDay) {
			reachedLimitToday = true;
			return false;
		}

		return true;
	}

	//------------------------------------------------------------------------

	private void initTimeForCurrentDay(long currentTime) {
		// set end time of the current day (so that we now when new day starts)
		EODTime = SQTime.correctDayEnd(currentTime);

		openTimeToday = SQTime.correctDayStart(currentTime);

		reachedLimitToday = false;
	}
	
	//------------------------------------------------------------------------

	private int getNumberOfTradesToday() throws JFException {
		int todayTradesCount = 0;
		int i = 0;

		// count closed trades that started today
		int startAt = lastHistoryPositionChecked -10;
		if(startAt < 0) {
			startAt = 0;
		}

		orders = sqGetHistoryOrders("any");
		for(i=startAt;i<orders.size();i++) {
			order = orders.get(i);
			lastHistoryPositionChecked = i;

			if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

			if(order.getFillTime() >= openTimeToday) {
				todayTradesCount++;
			}
		}

		orders = engine.getOrders();	
		for(i=0; i<orders.size(); i++) {
			order = orders.get(i);

			if(!checkMagicNumber(getOrderMagicNumber(order))) continue;

			if(order.getFillTime() >= openTimeToday) {
				todayTradesCount++;
			}
		}

		return todayTradesCount;
	}      
}

// create variable for class instance (required)
private CMaxTradesPerDay objMaxTradesPerDay = new CMaxTradesPerDay();

//------------------------------------------------------------------
// -- CMinMaxSLPT
//------------------------------------------------------------------
private class  CMinMaxSLPT implements ITradingOption {

	private CMinMaxSLPT() {
	}

	//------------------------------------------------------------------------

	@Override
	public boolean onTick() throws JFException {
		return true;
	}
}

// create variable for class instance (required)
private CMinMaxSLPT objMinMaxSLPT = new CMinMaxSLPT();	
// Money Management - Fixed Size used	
//------------------------------------------------------------------
//------------------------------------------------------------------
// ExitMethods includes
//------------------------------------------------------------------
//------------------------------------------------------------------


// Move Stop Loss to Break Even
void sqManageSL2BE(IOrder order) throws JFException {  
   ticket = order.getLabel();

   int val = sqGetGlobalIntVariable(ticket, "MoveSL2BE");
   if(val == 0) {
      return;
   }
   
   instrument = order.getInstrument();

   double bid = history.getLastTick(instrument).getBid();
   double ask = history.getLastTick(instrument).getAsk();

   double moveSLAtValue = sqGetValueByIdentification(val, instrument);

   if(moveSLAtValue > 0) {
      double newSL = 0;
      int error;

      int valueType = sqGetGlobalIntVariable(ticket, "MoveSL2BEType");
      orderType = order.getOrderCommand();

      if(orderType.isLong()) {
         if(valueType == SLPTTYPE_RANGE) {
            moveSLAtValue = bid - moveSLAtValue;
         }
      } else {
         if(valueType == SLPTTYPE_RANGE) {
            moveSLAtValue = ask + moveSLAtValue;
         }
      }

      moveSLAtValue = sqFixMarketPrice(moveSLAtValue, instrument);
      double addPips = sqFixMarketPrice(sqGetValueByIdentification(sqGetGlobalIntVariable(ticket, "SL2BEAddPips"), instrument), instrument);
      
      double currentSL = order.getStopLossPrice();

      if(orderType.isLong()) {
         newSL = sqFixMarketPrice(order.getOpenPrice() + addPips, instrument);

         if ((order.getOpenPrice() <= moveSLAtValue || sqDoublesAreEqual(order.getOpenPrice(), moveSLAtValue)) && (currentSL == 0 || currentSL < newSL) && !sqDoublesAreEqual(currentSL, newSL)) {
            print("Moving SL 2 BE for order with ticket: " + ticket + " to :" + newSL);
            sqOrderModify(order, order.getOpenPrice(), newSL, order.getTakeProfitPrice());
         }

      } else { // orderType == SELL
         newSL = sqFixMarketPrice(order.getOpenPrice() - addPips, instrument);

         if ((order.getOpenPrice() >= moveSLAtValue || sqDoublesAreEqual(order.getOpenPrice(), moveSLAtValue)) && (currentSL == 0 || currentSL > newSL) && !sqDoublesAreEqual(currentSL, newSL)) {
            print("Moving SL 2 BE for order with ticket: " + ticket + "  to :" + newSL);
            sqOrderModify(order, order.getOpenPrice(), newSL, order.getTakeProfitPrice());
         }
      }
   }
}
// Trailing Stop
void sqManageTrailingStop(IOrder order) throws JFException {
   ticket = order.getLabel();
	
   int val = sqGetGlobalIntVariable(ticket, "TrailingStop");
   if(val == 0) {
      return;
   }
   
   instrument = order.getInstrument();

   double tsValue = sqGetValueByIdentification(val, instrument);
   
   double bid = history.getLastTick(instrument).getBid();
   double ask = history.getLastTick(instrument).getAsk();
   
   if(tsValue > 0) {
      double plValue;
      int error;

      int valueType = sqGetGlobalIntVariable(ticket, "TrailingStopType");
      orderType = order.getOrderCommand();

      if(orderType.isLong()) {
         if(valueType == SLPTTYPE_RANGE) {
            tsValue = bid - tsValue;
         }
      } else {
         if(valueType == SLPTTYPE_RANGE) {
            tsValue = ask + tsValue;
         }
      }

      tsValue = sqFixMarketPrice(tsValue, instrument);

      double tsActivation = sqFixMarketPrice(sqGetValueByIdentification(sqGetGlobalIntVariable(ticket, "TrailingActivation"), instrument), instrument);
      double currentSL = order.getStopLossPrice();

      if(orderType.isLong()) {
         plValue = sqFixMarketPrice(bid - order.getOpenPrice(), instrument);

         if ((plValue >= tsActivation || sqDoublesAreEqual(plValue, tsActivation)) && (currentSL == 0 || currentSL < tsValue) && !sqDoublesAreEqual(currentSL, tsValue)) {
            print("Moving trailing stop for order with ticket: " + order.getLabel() + " to :" + tsValue);
            sqOrderModify(order, order.getOpenPrice(), tsValue, order.getTakeProfitPrice());
         }
      } else { // orderType == SELL
         plValue = sqFixMarketPrice(order.getOpenPrice() - ask, instrument);

         if ((plValue >= tsActivation || sqDoublesAreEqual(plValue, tsActivation)) && (currentSL == 0 || currentSL > tsValue) && !sqDoublesAreEqual(currentSL, tsValue)) {
            print("Moving trailing stop for order with ticket: " + order.getLabel() + " to :" + tsValue);
            sqOrderModify(order, order.getOpenPrice(), tsValue, order.getTakeProfitPrice());
         }
      }
   }
}
void sqManageExitAfterXBars(IOrder order) throws JFException {
   ticket = order.getLabel();

   int exitBars = sqGetGlobalIntVariable(ticket, "ExitAfterBars");
   if(exitBars > 0) {
      if (sqGetOpenBarsForOrder(order, exitBars+10) >= exitBars) {
         print("Exit After ", exitBars, "bars - closing order with ticket: ", ticket);
         sqClosePositionAtMarket(order, 0, "Exit after "+exitBars+" bars");
      }
   }
}
//------------------------------------------------------------------

private double sqGetIndicatorByIdentification(String idHash, int shift) throws JFException {

   return 0;
}


//------------------------------------------------------------------

private double sqGetValueByIdentification(int idHash, Instrument instrument) throws JFException {

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   if(idHash == sqStringHash("0")) {
      return 0;
   }

   return 0;
}
	
}